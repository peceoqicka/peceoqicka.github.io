<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Peceoqicka的博客</title>
  
  
  <link href="http://peceoqicka.github.io/project/atom.xml" rel="self"/>
  
  <link href="http://peceoqicka.github.io/project/"/>
  <updated>2022-02-10T02:56:41.914Z</updated>
  <id>http://peceoqicka.github.io/project/</id>
  
  <author>
    <name>Peceoqicka</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【程序实现】已知两条线的直线方程，求交点</title>
    <link href="http://peceoqicka.github.io/project/2022/02/10/math_intersection_of_lines/"/>
    <id>http://peceoqicka.github.io/project/2022/02/10/math_intersection_of_lines/</id>
    <published>2022-02-10T01:30:00.000Z</published>
    <updated>2022-02-10T02:56:41.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="笔算法"><a href="#笔算法" class="headerlink" title="笔算法"></a>笔算法</h2><p>已知两条直线的方程：</p><p>$$A_1x+B_1y+C_1=0$$</p><p>$$A_2x+B_2y+C_2=0$$</p><p>大家都知道的求交点方法，消元：</p><p>$$A_1B_2x+B_1B_2y+B_2C_1=0$$</p><p>$$A_2B_1x+B_1B_2y+B_1C_2=0$$</p><p>然后两式相减：</p><p>$$(A_1B_2-A_2B_1)x=B_2C_1-B_1C_2$$</p><p>即可得到交点的x坐标：</p><blockquote><p>$$x=\frac{(A_1B_2-A_2B_1)}{B_2C_1-B_1C_2}$$</p></blockquote><p>然后带入方程1：</p><p>$$A_1[\frac{A_1B_2-A_2B_1}{B_2C_1-B_1C_2}]+B_1y+C_1=0$$</p><p>化简得到：</p><blockquote><p> $$y=\frac{C_1}{B_1}-\frac{A_1}{B_1}\frac{A_1B_2-A_2B_1}{B_2C_1-B_1C_2}$$</p></blockquote><p>如果按照以上方法用程序实现，也没什么问题，简单粗暴，但有没有更简单的方法呢，<strong>有！</strong></p><h2 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h2><h3 id="直线方程推导"><a href="#直线方程推导" class="headerlink" title="直线方程推导"></a>直线方程推导</h3><p>先来看另外一个问题，<strong>已知一条直线过两点$P_1(x_1,y_1)$和$P_2(x_2,y_2)$，求该直线方程</strong></p><p>设直线方程$Ax+By-C=0$</p><p>很容易可以推导出：</p><p>$$A=y_2-y_1$$</p><p>$$B=x_1-x_2$$</p><p>$$C=Ax_1+By_1$$</p><h3 id="直线交点公式"><a href="#直线交点公式" class="headerlink" title="直线交点公式"></a>直线交点公式</h3><p>设两条直线的方程为：</p><p>$$A_1x+B_1y-C_1=0$$</p><p>$$A_2x+B_2y-C_2=0$$</p><p>程序实现如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> det = A1*B2 - A2*B1</span><br><span class="line"><span class="keyword">if</span> (det == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//两条直线平行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> x = (B2*C1-B1*C2)/det</span><br><span class="line">    <span class="keyword">val</span> y = (A1*C2-A2*C1)/det</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个公式是怎么得出来的呢</strong>，给方程1乘以$B_2$，给方程2乘以$B_1$，也就是使用上述消元法可得到：</p><p>$$A_1B_2x+B_1B_2y=C_1B_2$$</p><p>$$A_2B_1x+B_1B_2y=C_2B_1$$</p><p>两式相减：</p><blockquote><p>$$(A_1B_2-A_2B_1)x=C_1B_2-C_2B_1$$</p></blockquote><p>可以看到x的乘数就是上边的<strong>det变量</strong>，而等式右边的算式就是下边的<strong>x计算式的分子</strong></p><p><strong>同理，y的计算方法也是如此：</strong></p><p>$$A_1A_2x+A_2B_1y=C_1A_2$$</p><p>$$A_1A_2x+A_1B_2y=C_2A_1$$</p><p>两式相减：</p><blockquote><p>$$(A_1B_2-A_2B_1)y=C_2A_1-C_1A_2$$</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;笔算法&quot;&gt;&lt;a href=&quot;#笔算法&quot; class=&quot;headerlink&quot; title=&quot;笔算法&quot;&gt;&lt;/a&gt;笔算法&lt;/h2&gt;&lt;p&gt;已知两条直线的方程：&lt;/p&gt;
&lt;p&gt;$$A_1x+B_1y+C_1=0$$&lt;/p&gt;
&lt;p&gt;$$A_2x+B_2y+C_2=0$$&lt;/</summary>
      
    
    
    
    
    <category term="Math" scheme="http://peceoqicka.github.io/project/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>flutter学习笔记（一）：搭建开发环境</title>
    <link href="http://peceoqicka.github.io/project/2019/12/25/flutter-1/"/>
    <id>http://peceoqicka.github.io/project/2019/12/25/flutter-1/</id>
    <published>2019-12-25T02:39:32.000Z</published>
    <updated>2019-12-26T03:14:27.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><blockquote><p>Flutter是Google推出的仅需一次开发，即可多平台发布原生App的UI套件集。（移动端、web端、桌面端）<br>Flutter具有以下特性：</p><ul><li>快速开发</li><li>丰富灵活的UI</li><li>原生</li></ul></blockquote><h2 id="安装Flutter"><a href="#安装Flutter" class="headerlink" title="安装Flutter"></a>安装Flutter</h2><ul><li>下载<br>可以选择：</li></ul><p>1.从官网下载安装包；<br>2.使用git命令下载<br>这里选择使用git命令下载，在E盘根目录，右键点击空白处在弹出的菜单中选择<code>git bash here</code>，输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/flutter/flutter.git</span><br></pre></td></tr></table></figure><p>然后执行命令。</p><ul><li>添加环境变量<br>将<code>E:\flutter\bin;</code>添加到<code>Path</code>变量中。</li><li>执行环境检查<br>打开cmd，输入<code>flutter doctor</code>并执行，flutter将会检查环境配置的情况，例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-] Android toolchain - develop <span class="keyword">for</span> Android devices</span><br><span class="line">    • Android SDK at D:\Android\sdk</span><br><span class="line">    ✗ Android SDK is missing <span class="built_in">command</span> line tools; download from https://goo.gl/XxQghQ</span><br><span class="line">    • Try re-installing or updating your Android SDK,</span><br><span class="line">      visit https://flutter.dev/setup/<span class="comment">#android-setup for detailed instructions.</span></span><br></pre></td></tr></table></figure></li><li>下载Android SDK</li><li>下载Android Studio，打开并添加插件Flutter</li><li>准备测试设备，如添加一个虚拟机</li></ul><h2 id="运行Demo"><a href="#运行Demo" class="headerlink" title="运行Demo"></a>运行Demo</h2><p>选择新建Flutter项目，等自动生成了demo项目，启动虚拟机，再点击右上角的运行按钮。启动完可以看到如下画面：</p><blockquote><p>修改代码后，无论是按Ctrl+S保存，还是按热重启（hot reload），flutter都会无缝快速重启app</p></blockquote><h2 id="写第一个APP"><a href="#写第一个APP" class="headerlink" title="写第一个APP"></a>写第一个APP</h2><p><strong>Flutter</strong>的开发语言是<strong>Dart</strong>，<strong>Dart</strong>这门语言吸收了现代语言的一些优质特性，所以熟悉面向对象开发的人能很快上手。这里不过多的对<strong>Dart</strong>语法进行说明，只是跟随官方文档书写第一个App。</p><p>本例将要实现一个随机生成名称的列表，并且列表将无限生成，效果图如下：</p><ul><li><p>新建Flutter项目<br>项目名称建议为<strong>小写字母加下划线分割单词</strong>，例如<strong>flutter_demo</strong></p></li><li><p>删除多余的自动生成的代码<br>项目新建完成IDE会自动生成一些代码，除了<strong>MyApp</strong>是主题框架，它下方的代码都是我们不需要的，所以手动删除，并修改代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">Widget  build(BuildContext context) &#123;</span><br><span class="line"><span class="keyword">return</span> MaterialApp(</span><br><span class="line">title: <span class="string">&#x27;Welcome to Flutter&#x27;</span>,</span><br><span class="line">home: Scaffold(</span><br><span class="line">appBar: AppBar(</span><br><span class="line">title: Text(<span class="string">&#x27;Welcome to Flutter&#x27;</span>),</span><br><span class="line">),</span><br><span class="line">body: Center(</span><br><span class="line">child: Text(<span class="string">&#x27;Hello World&#x27;</span>),</span><br><span class="line">),</span><br><span class="line">),</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行（保存）可以看到如图效果：</p></li><li><p>使用名称生成库<br>随机名称的生成需要用到一个库<strong>english_words</strong>，打开<strong>pubsec.yaml</strong>文件，找到<strong>dependencies</strong>并在其下方添加<strong>english_words</strong>，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">flutter:</span></span><br><span class="line"><span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line"><span class="attr">cupertino_icons:</span> <span class="string">^0.1.2</span></span><br><span class="line"><span class="attr">english_words:</span> <span class="string">^3.1.0</span></span><br></pre></td></tr></table></figure><p>保存并点击右上角的<strong>Packaget Get</strong>，然后将自动下载库，可以看到控制台输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ flutter pub get</span><br><span class="line">Running &quot;flutter pub get&quot; in startup_namer...</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>在<strong>main.dart</strong>中引入库：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:english_words/english_words.dart&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><p>修改上述代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">Widget  build(BuildContext context) &#123;</span><br><span class="line"><span class="keyword">final</span> wordPair = WordPair.random();</span><br><span class="line"><span class="keyword">return</span> MaterialApp(</span><br><span class="line">title: <span class="string">&#x27;Welcome to Flutter&#x27;</span>,</span><br><span class="line">home: Scaffold(</span><br><span class="line">appBar: AppBar(</span><br><span class="line">title: Text(<span class="string">&#x27;Welcome to Flutter&#x27;</span>),</span><br><span class="line">),</span><br><span class="line">body: Center(</span><br><span class="line">child: Text(wordPair.asPascalCase),</span><br><span class="line">),</span><br><span class="line">),</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新运行可以看到随机生成的名称：</p><ul><li>添加Stateful Widget<blockquote><p>Stateless Widgets 是不可变的，它们的属性都不可变。<br>Stateful Widgets 维持了可在控件生命周期内可变的状态。实现一个Stateful Widget需要至少两个类：1）StatefulWidget类； 2）State类。StatefulWidget类自身可变，但是State类维持整个控件的生命周期不变。</p></blockquote></li></ul><p>添加State类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomWordsState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">RandomWords</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加StatefulWidget类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomWords</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">RandomWordsState createState() =&gt; RandomWordsState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后给<strong>RandomWordsState</strong>补上<strong>build</strong>方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomWordsState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">RandomWords</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line"><span class="keyword">final</span> wordPair = WordPair.random();</span><br><span class="line"><span class="keyword">return</span> Text(wordPair.asPascalCase);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还要替换<strong>MyApp</strong>中的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body:Center(child:RandomWords(),),</span><br></pre></td></tr></table></figure><p>重新运行，看到的效果与上一张图相同。</p><ul><li>做一个无限滑动的列表<br>在<strong>RandomWordsState</strong>中添加一个数组用于保存生成的名称，并添加一个大号的字体：<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomWordsState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">RandomWords</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">final</span> _suggestions = &lt;WordPair&gt;[];</span><br><span class="line"><span class="keyword">final</span> _biggerFont = <span class="keyword">const</span> TextStyle(fontSize: <span class="number">18.0</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>添加**<code>_buildSuggestions</code>**方法：<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Widget _buildSuggestions() &#123;</span><br><span class="line"><span class="keyword">return</span> ListView.builder(</span><br><span class="line">padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">16.0</span>),</span><br><span class="line">itemBuilder: (context, i) &#123;</span><br><span class="line"><span class="keyword">if</span> (i.isOdd) <span class="keyword">return</span> Divider();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> index = i ~/ <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= _suggestions.length) &#123;</span><br><span class="line">_suggestions.addAll(generateWordPairs().take(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _buildRow(_suggestions[index]);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>添加**<code>_buildRow</code>**方法：<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Widget _buildRow(WordPair pair) &#123;</span><br><span class="line"><span class="keyword">return</span> ListTile(</span><br><span class="line">title: Text(</span><br><span class="line">pair.asPascalCase,</span><br><span class="line">style: _biggerFont,</span><br><span class="line">),</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>修改<strong>RandomWordsState</strong>的<strong>build</strong>方法：<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line"><span class="keyword">return</span> Scaffold(</span><br><span class="line">appBar: AppBar(</span><br><span class="line">title: Text(<span class="string">&#x27;Startup Name Generator&#x27;</span>),</span><br><span class="line">),</span><br><span class="line">body: _buildSuggestions(),</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>修改<strong>MyApp</strong>的<strong>build</strong>方法：<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> build(BuildContext context)&#123;</span><br><span class="line"><span class="keyword">return</span> MaterialApp(</span><br><span class="line">title: <span class="string">&#x27;Startup Name Generator&#x27;</span>,</span><br><span class="line">home: RandomWords(),</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>重新运行App，可以看到预期的效果：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Flutter&quot;&gt;&lt;a href=&quot;#Flutter&quot; class=&quot;headerlink&quot; title=&quot;Flutter&quot;&gt;&lt;/a&gt;Flutter&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Flutter是Google推出的仅需一次开发，即可多平台发布原生App的</summary>
      
    
    
    
    <category term="Development" scheme="http://peceoqicka.github.io/project/categories/Development/"/>
    
    
    <category term="Flutter" scheme="http://peceoqicka.github.io/project/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>透过源码学习CoordinatorLayout与Behavior</title>
    <link href="http://peceoqicka.github.io/project/2019/12/11/android-source-coordinatorlayout/"/>
    <id>http://peceoqicka.github.io/project/2019/12/11/android-source-coordinatorlayout/</id>
    <published>2019-12-11T06:53:39.000Z</published>
    <updated>2020-01-19T07:09:43.080Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>CoordinatorLayout（协调布局）</strong>是将<strong>嵌套滑动</strong>的泛用性发挥到极致的控件，只需要通过简单配置它的子View的<strong>Behavior（行为）</strong>就可以实现复杂而炫丽的效果。</p></blockquote><h2 id="Behavior"><a href="#Behavior" class="headerlink" title="Behavior"></a>Behavior</h2><p>Behavior是CoordinatorLayout的内部静态类，通过继承Behavior可以实现自定义的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Behavior</span>&lt;<span class="title">V</span> <span class="keyword">extends</span> <span class="title">View</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Behavior</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Behavior</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(<span class="meta">@NonNull</span> CoordinatorLayout parent, <span class="meta">@NonNull</span> V child, <span class="meta">@NonNull</span> MotionEvent ev)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(<span class="meta">@NonNull</span> CoordinatorLayout parent, <span class="meta">@NonNull</span> V child, <span class="meta">@NonNull</span> MotionEvent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">layoutDependsOn</span><span class="params">(<span class="meta">@NonNull</span> CoordinatorLayout parent, <span class="meta">@NonNull</span> V child, <span class="meta">@NonNull</span> View dependency)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 这个Behavior改变了child view的大小或位置; false 则没有</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDependentViewChanged</span><span class="params">(<span class="meta">@NonNull</span> CoordinatorLayout parent, <span class="meta">@NonNull</span> V child, <span class="meta">@NonNull</span> View dependency)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDependentViewRemoved</span><span class="params">(<span class="meta">@NonNull</span> CoordinatorLayout parent, <span class="meta">@NonNull</span> V child, <span class="meta">@NonNull</span> View dependency)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 由此Behavior测量此View; false 父级CoordinatorLayout测量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onMeasureChild</span><span class="params">(<span class="meta">@NonNull</span> CoordinatorLayout parent, <span class="meta">@NonNull</span> V child, <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed, <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 由此Behavior布局此View; false 父级CoordinatorLayout布局</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onLayoutChild</span><span class="params">(<span class="meta">@NonNull</span> CoordinatorLayout parent, <span class="meta">@NonNull</span> V child, <span class="keyword">int</span> layoutDirection)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 此Behavior接收嵌套滑动事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(<span class="meta">@NonNull</span> CoordinatorLayout coordinatorLayout, <span class="meta">@NonNull</span> V child, <span class="meta">@NonNull</span> View directTargetChild, <span class="meta">@NonNull</span> View target, <span class="meta">@ScrollAxis</span> <span class="keyword">int</span> axes, <span class="meta">@NestedScrollType</span> <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(type == ViewCompat.TYPE_TOUCH) &#123;</span><br><span class="line"><span class="keyword">return</span> onStartNestedScroll(coordinatorLayout, child, directTargetChild, target, axes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScrollAccepted</span><span class="params">(<span class="meta">@NonNull</span> CoordinatorLayout coordinatorLayout, <span class="meta">@NonNull</span> V child, <span class="meta">@NonNull</span> View directTargetChild, <span class="meta">@NonNull</span> View target, <span class="meta">@ScrollAxis</span> <span class="keyword">int</span> axes, <span class="meta">@NestedScrollType</span> <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(type == ViewCompat.TYPE_TOUCH) &#123;</span><br><span class="line">onNestedScrollAccepted(coordinatorLayout, child, directTargetChild, target, axes);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStopNestedScroll</span><span class="params">(<span class="meta">@NonNull</span> CoordinatorLayout coordinatorLayout, <span class="meta">@NonNull</span> V child, <span class="meta">@NonNull</span> View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed, <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(<span class="meta">@NonNull</span> CoordinatorLayout coordinatorLayout, <span class="meta">@NonNull</span> V child, <span class="meta">@NonNull</span> View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed, <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, <span class="meta">@NestedScrollType</span> <span class="keyword">int</span> type, <span class="meta">@NonNull</span> <span class="keyword">int</span>[] consumed)</span> </span>&#123;</span><br><span class="line">consumed[<span class="number">0</span>] += dxUnconsumed;</span><br><span class="line">consumed[<span class="number">1</span>] += dyUnconsumed;</span><br><span class="line">onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, type)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(<span class="meta">@NonNull</span> CoordinatorLayout coordinatorLayout, <span class="meta">@NonNull</span> V child, <span class="meta">@NonNull</span> View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="meta">@NonNull</span> <span class="keyword">int</span>[] consumed, <span class="meta">@NestedScrollType</span> <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(type == ViewCompat.TYPE_TOUCH) &#123;</span><br><span class="line">onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上源码摘录了Behavior常用的方法，从简单到复杂的需求皆可实现。简单需求可以搭配<code>layoutDependsOn</code>和<code>onDependentViewChanged</code>，复杂需求可自行定制嵌套滑动的细节。</p><h3 id="Behavior的绑定方式"><a href="#Behavior的绑定方式" class="headerlink" title="Behavior的绑定方式"></a>Behavior的绑定方式</h3><h4 id="通过布局属性绑定"><a href="#通过布局属性绑定" class="headerlink" title="通过布局属性绑定"></a>通过布局属性绑定</h4><p>即在布局文件中通过app:layout_behavior添加，看看源码是怎么解析的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Behavior <span class="title">parseBehavior</span><span class="params">(Context context, AttributeSet attrs, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (TextUtils.isEmpty(name)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String fullName;</span><br><span class="line"><span class="keyword">if</span> (name.startsWith(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">//相对于app的包，在前面添加app包名</span></span><br><span class="line">fullName = context.getPackageName() + name;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.indexOf(<span class="string">&#x27;.&#x27;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//完整包名</span></span><br><span class="line">fullName = name;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//WIDGET_PACKAGE_NAME = pkg != null ? pkg.getName() : null</span></span><br><span class="line">fullName = ！TextUtils.isEmpty(WIDGET_PACKAGE_NAME) ? (WIDGET_PACKAGE_NAME + <span class="string">&#x27;.&#x27;</span> + name) : name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Map&lt;String, Constructor&lt;Behavior&gt;&gt; constructors = sConstructors.get();</span><br><span class="line"><span class="keyword">if</span> (constructors == <span class="keyword">null</span>) &#123;</span><br><span class="line">constructors = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">sConstructors.set(constructors);</span><br><span class="line">&#125;</span><br><span class="line">Constructor&lt;Behavior&gt; c = constructors.get(fullName);</span><br><span class="line"><span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">final</span> Class&lt;Behavior&gt; clazz = (Class&lt;Behavior&gt;) Class.forName(fullName, <span class="keyword">false</span>, context.getClassLoader());</span><br><span class="line">c = clazz.getConstructor(CONSTRUCTOR_PARAMS);</span><br><span class="line">c.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">constructors.put(fullName, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c.newInstance(context, attrs);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Could not inflate Behavior subclass &quot;</span> + fullName, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在布局文件中通过填写的全名或者半名自动补全查找，然后通过反射实例化对应的Behavior类。接下来再来看看，这个方法在哪里调用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutParams</span> <span class="keyword">extends</span> <span class="title">MarginLayoutParams</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">LayoutParams(<span class="meta">@NonNull</span> Context context, <span class="meta">@Nullable</span> AttributeSet attrs) &#123;</span><br><span class="line"><span class="keyword">super</span>(context, attrs);</span><br><span class="line">...</span><br><span class="line">mBehaviorResolved = a.hasValue(R.styleable.CoordinatorLayout_Layout_layout_behavior);</span><br><span class="line"><span class="keyword">if</span> (mBehaviorResolved) &#123;</span><br><span class="line">mBehavior = parseBehavior(context, attrs, a.getString(R.styleable.CoordinatorLayout_Layout_layout_behavior));</span><br><span class="line">&#125;</span><br><span class="line">a.recycle();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//解析完成并绑定成功后，调用回调方法通知</span></span><br><span class="line">mBehavior.onAttachedToLayoutParams(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Behavior是在LayoutParams初始化时解析并绑定的。</p><h4 id="绑定默认行为"><a href="#绑定默认行为" class="headerlink" title="绑定默认行为"></a>绑定默认行为</h4><p>旧版本的默认行为是在自定义的类上添加注解**@DefaultBehavior()<strong>，而新版本则要求自定义类实现</strong>AttachedBehavior<strong>接口，并通过</strong>getBehavior()**方法返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LayoutParams <span class="title">getResolvedLayoutParams</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> LayoutParams result = (LayoutParams) child.getLayoutParams();</span><br><span class="line"><span class="keyword">if</span> (!result.mBehaviorResolved) &#123;</span><br><span class="line"><span class="comment">//就是这里，看到了吧</span></span><br><span class="line"><span class="keyword">if</span> (child <span class="keyword">instanceof</span> AttachedBehavior) &#123;</span><br><span class="line">Behavior attachedBehavior = ((AttachedBehavior) child).getBehavior();</span><br><span class="line"><span class="keyword">if</span> (attachedBehavior == <span class="keyword">null</span>) &#123;</span><br><span class="line">Log.e(TAG, <span class="string">&quot;Attached behavior class is null&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">result.setBehavior(attachedBehavior);</span><br><span class="line">result.mBehaviorResolved = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//旧版通过注解查找Behavior class的方式</span></span><br><span class="line">Class&lt;?&gt; childClass = child.getClass();</span><br><span class="line">DefaultBehavior defaultBehavior = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (childClass != <span class="keyword">null</span> </span><br><span class="line">                   &amp;&amp; (defaultBehavior = childClass.getAnnotation(DefaultBehavior.class)) </span><br><span class="line">                   == <span class="keyword">null</span>) &#123;</span><br><span class="line">childClass = childClass.getSuperclass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (defaultBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">result.setBehavior(</span><br><span class="line">                        defaultBehavior.value().getDeclaredConstructor().newInstance());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">Log.e(TAG, <span class="string">&quot;Default behavior class &quot;</span> + defaultBehavior.value().getName() </span><br><span class="line">+ <span class="string">&quot;could not be instantiated. Did you forget&quot;</span> </span><br><span class="line">+ <span class="string">&quot; a default constructor?&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">result.mBehaviorResolved = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Behavior与行为交互"><a href="#Behavior与行为交互" class="headerlink" title="Behavior与行为交互"></a>Behavior与行为交互</h3><p>CoordinatorLayout的本质还是通过Behavior将嵌套滑动“发散”出去，“分给”一个或多个子View同步享用。要知道它是怎么做到的，只要看看它其中的与嵌套滑动相关的方法即可，例如<strong>onStartNestedScroll</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(View child, View target, <span class="keyword">int</span> axes, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line"><span class="keyword">final</span> View view = getChildAt(i);</span><br><span class="line"><span class="keyword">if</span> (view.getVisibility() == View.GONE) &#123;</span><br><span class="line"><span class="comment">//如果它消失了，就不分发消息</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> LayoutParams lp = (LayoutParams) view.getLayoutParams();</span><br><span class="line"><span class="keyword">final</span> Behavior viewBehavior = lp.getBehavior();</span><br><span class="line"><span class="keyword">if</span> (viewBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//它会尝试从child的LayoutParams中获取Behavior</span></span><br><span class="line"><span class="comment">//并询问Behavior是否接收嵌套滑动事件</span></span><br><span class="line"><span class="comment">//如果接收，后续的事件就会发送给对应的Behavior</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accepted = viewBehavior.onStartNestedScroll(<span class="keyword">this</span>, view, child, target, axes, type);</span><br><span class="line">handled |= accepted;</span><br><span class="line">lp.setNestedScrollAccepted(type, accepted);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">lp.setNestedScrollAccepted(type, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>onNestedScroll</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(<span class="meta">@NonNull</span> View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed, <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, <span class="meta">@ViewCompat</span>.NestedScrollType <span class="keyword">int</span> type, <span class="meta">@NonNull</span> <span class="keyword">int</span>[] consumed)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line"><span class="keyword">boolean</span> accepted = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> xConsumed = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> yConsumed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line"><span class="keyword">final</span> View view = getChildAt(i);</span><br><span class="line"><span class="keyword">if</span> (view.getVisibility() == GONE) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> LayoutParams lp = (LayoutParams) view.getLayoutParams();</span><br><span class="line"><span class="keyword">if</span> (!lp.isNestedScrollAccepted(type)) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Behavior viewBehavior = lp.getBehavior();</span><br><span class="line"><span class="keyword">if</span> (viewBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">mBehaviorConsumed[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">mBehaviorConsumed[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">viewBehavior.onNestedScroll(<span class="keyword">this</span>, view, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, type, mBehaviorConsumed);</span><br><span class="line"></span><br><span class="line">xConsumed = dxUnconsumed &gt; <span class="number">0</span> ? Math.max(xConsumed, mBehaviorConsumed[<span class="number">0</span>]) : Math.min(xConsumed, mBehaviorConsumed[<span class="number">0</span>]);</span><br><span class="line">yConsumed = dyUnconsumed &gt; <span class="number">0</span> ? Math.max(yConsumed, mBehaviorConsumed[<span class="number">1</span>]) : Math.min(yConsumed, mBehaviorConsumed[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">accepted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumed[<span class="number">0</span>] += xConsumed;</span><br><span class="line">consumed[<span class="number">1</span>] += yConsumed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (accepted) &#123;</span><br><span class="line">onChildViewChanged(EVENT_NESTED_SCROLL);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>onNestedScroll</strong>方法中可以明显的看到，如果有其中任意一个Child的Behavior接收并消费了事件，那么就会在方法结束位置调用<strong>onChildViewChanged</strong>方法，<strong>onChildViewChanged</strong>顾名思义——有View发生了改变，很容易就可以联想到一定会触发某个Behavior的<strong>onDependentViewChanged</strong>方法（如果有View依赖这个消费事件的View的情况下）。</p><p>为了印证这种想法，就需要查看<strong>onChildViewChanged</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onChildViewChanged</span><span class="params">(<span class="meta">@DispatchChangeEvent</span> <span class="keyword">final</span> <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = ViewCompat.getLayoutDirection(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> childCount = mDependencySortedChildren.size();</span><br><span class="line"><span class="keyword">final</span> Rect inset = acquireTempRect();</span><br><span class="line"><span class="keyword">final</span> Rect drawRect = acquireTempRect();</span><br><span class="line"><span class="keyword">final</span> Rect lastDrawRect = acquireTempRect();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCout; i++) &#123;</span><br><span class="line"><span class="keyword">final</span> View child = mDependencySortedChildren.get(i);</span><br><span class="line"><span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line"><span class="keyword">if</span> (type == EVENT_PRE_DRAW &amp;&amp; child.getVisibility() == View.GONE) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...省略一部分关于重定位的代码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; childCount; j++) &#123;</span><br><span class="line"><span class="keyword">final</span> View checkChild = mDependencySortedChildren.get(j);</span><br><span class="line"><span class="keyword">final</span> LayoutParams checkLp = (LayoutParams) checkChild.getLayoutParams();</span><br><span class="line"><span class="keyword">final</span> Behavior b = checkLp.getBehavior();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (b != <span class="keyword">null</span> &amp;&amp; b.layoutDependsOn(<span class="keyword">this</span>, checkChild, child)) &#123;</span><br><span class="line"><span class="keyword">if</span>(type == EVENT_PRE_DRAW &amp;&amp; checkLp.getChangedAfterNestedScroll()) &#123;</span><br><span class="line">checkLp.resetChangedAfterNestedScroll();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> EVENT_VIEW_REMOVED:</span><br><span class="line">b.onDependentViewRemoved(<span class="keyword">this</span>, childChild, child);</span><br><span class="line">handled = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">//果然如此，这就是我们要找的</span></span><br><span class="line">handled = b.onDependentViewChanged(<span class="keyword">this</span>, checkChild, child);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type == EVENT_NESTED_SCROLL) &#123;</span><br><span class="line">checkLp.setChangedAfterNestedScroll(handled);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">releaseTempRect(inset);</span><br><span class="line">releaseTempRect(drawRect);</span><br><span class="line">releaseTempRect(lastDrawRect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果不其然，在倒数几行的位置找到了<code>handled = b.onDependentViewChanged(this, checkChild, child)</code>，整个流程就已经连起来了。</p><h2 id="CoordinatorLayout"><a href="#CoordinatorLayout" class="headerlink" title="CoordinatorLayout"></a>CoordinatorLayout</h2><p>还记得刚才说Behavior绑定的时候找到的<code>getResolvedLayoutParams</code>吗，那么它是在哪里调用的呢，继续找，找到如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mDependencySortedChildren.clear();</span><br><span class="line">mChildDag.clear();<span class="comment">//这是一个有向无环图(DirectedAcyclicGraph&lt;View&gt;)</span></span><br><span class="line"><span class="comment">//也就是树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = getChildCount(); i &lt; count; i++) &#123;</span><br><span class="line"><span class="keyword">final</span> View view = getChildAt(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析并绑定Behavior</span></span><br><span class="line"><span class="keyword">final</span> LayoutParams lp = getResolvedLayoutParams(view);</span><br><span class="line">lp.findAnchorView(<span class="keyword">this</span>, view);</span><br><span class="line"></span><br><span class="line">mChildDag.addNode(view);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j == i) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> View other = getChildAt(j);</span><br><span class="line"><span class="keyword">if</span> (lp.dependsOn(<span class="keyword">this</span>, view, other)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mChildDag.contains(other)) &#123;</span><br><span class="line">mChildDag.addNode(other);</span><br><span class="line">&#125;</span><br><span class="line">mChildDag.addEdge(other, view);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将通过深度优先搜索得到的排序过后的结果添加到mDependencySortedChildren中</span></span><br><span class="line">mDependencySortedChildren.addAll(mChildDag.getSortedList());</span><br><span class="line">Collections.reverse(mDependencySortedChildren);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在<code>onMeasure</code>方法中调用，准备好所有的子节点，然后再开始测量，接着再进行布局。对于所有节点，都会尝试优先查找节点的<code>LayoutParams</code>是否包含<code>Behavior</code>，如果包含，再询问<code>Behavior</code>是否接管测量或者布局（即<code>behavior.onMeasureChild</code>和<code>behavior.onLayoutChild</code>）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;CoordinatorLayout（协调布局）&lt;/strong&gt;是将&lt;strong&gt;嵌套滑动&lt;/strong&gt;的泛用性发挥到极致的控件，只需要通过简单配置它的子View的&lt;strong&gt;Behavior（行为）&lt;/strong&gt;就可</summary>
      
    
    
    
    
    <category term="Android" scheme="http://peceoqicka.github.io/project/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android NestedScroll 嵌套滑动机制学习笔记</title>
    <link href="http://peceoqicka.github.io/project/2019/12/10/android-source-nestedscroll/"/>
    <id>http://peceoqicka.github.io/project/2019/12/10/android-source-nestedscroll/</id>
    <published>2019-12-10T01:34:18.000Z</published>
    <updated>2020-01-19T07:06:53.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nested-Scroll"><a href="#Nested-Scroll" class="headerlink" title="Nested Scroll"></a>Nested Scroll</h1><blockquote><p>当一个可滑动ViewGroup内部包含另一个可滑动View，用户触摸内部可滑动View时，应当首先滑动内部View，内部View滑不动时外部ViewGroup应接着进行滑动</p></blockquote><p>以上描述的是用户预期的体验，但是事实上，这种效果违背了一个事件只有一个View进行消费的约定，因此按照常规的Touch事件分发机制这种效果是很难实现的。所以需要一套全新的滑动机制——<code>Nested Scroll（嵌套滑动）</code></p><p><strong>嵌套滑动</strong>是由内部View发起，可由内部View和外部View共同消费一个事件的机制。当检测到一个滑动事件的时候，先由内部View开启嵌套滑动，交由外部View预先进行滑动距离消费，没有消费完的由内部View进行消费，如果内部View还是没有消费完，再交由外部View消费，如此反复，直至消费完为止。消费顺序即<code>parent-&gt;child-&gt;parent-&gt;child-&gt;...-&gt;child</code></p><p>嵌套滑动是在5.0之后添加到View和ViewGroup中给几乎所有的View增加了支持的一系列代码，如使用频率极高的<strong>RecyclerView</strong>、<strong>NestedScrollView</strong>等。而与此同时，Google将其中的主要方法和辅助工具类提炼了出来，以供开发者们在自定义View时使用。</p><p><strong>NestedScrollingChild（省略了Fling相关的方法）</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedScrollingChild</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setNestedScrollingEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isNestedScrollingEnabled</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startNestedScroll</span><span class="params">(<span class="meta">@ScrollAxis</span> <span class="keyword">int</span> axes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stopNestedScroll</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNestedScrollingParent</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dispatchNestedScroll</span><span class="params">(<span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="meta">@Nullable</span> <span class="keyword">int</span>[] offsetInWindow)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Nullable</span> <span class="keyword">int</span>[] consumed, <span class="meta">@Nullable</span> <span class="keyword">int</span>[] offsetInWindow)</span></span></span><br><span class="line"><span class="function">......</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>NestedScrollingParent（省略了Fling相关的方法）</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedScrollingParent</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(<span class="meta">@NonNull</span> View child, <span class="meta">@NonNull</span> View target, <span class="meta">@ScrollAxis</span> <span class="keyword">int</span> axes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onNestedScrollAccepted</span><span class="params">(<span class="meta">@NonNull</span> View child, <span class="meta">@NonNull</span> View target, <span class="meta">@ScrollAxis</span> <span class="keyword">int</span> axes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onStopNestedScroll</span><span class="params">(<span class="meta">@NonNullView</span> target)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(<span class="meta">@NonNull</span> View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed, <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(<span class="meta">@NonNull</span> View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="meta">@NonNull</span> <span class="keyword">int</span>[] consumed)</span></span>;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNestedScrollAxes</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二版接口相比于第一版，主要区别是，其中一些方法添加了一个滑动类型参数（触摸、惯性滑动）</strong></p><p><strong>NestedScrollingChild2</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedScrollingChild2</span> <span class="keyword">extends</span> <span class="title">NestedScrollingChild</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startNestedScroll</span><span class="params">(<span class="meta">@ScrollAxis</span> <span class="keyword">int</span> axes, <span class="meta">@NestedScrollType</span> <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stopNestedScroll</span><span class="params">(<span class="meta">@NestedScrollType</span> <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNestedScrollingParent</span><span class="params">(<span class="meta">@NestedScrollType</span> <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dispatchNestedScroll</span><span class="params">(<span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed, <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, <span class="meta">@Nullable</span> <span class="keyword">int</span>[] offsetInWindow, <span class="meta">@NestedScrollType</span> <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="meta">@Nullable</span> <span class="keyword">int</span>[] consumed, <span class="meta">@Nullable</span> <span class="keyword">int</span>[] offsetInWindow, <span class="meta">@NestedScrollType</span> <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NestedScrollingParent2</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedScrollingParent2</span>  <span class="keyword">extends</span> <span class="title">NestedScrollingParent</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(<span class="meta">@NonNull</span> View child, <span class="meta">@NonNull</span> View target, <span class="meta">@ScrollAxis</span> <span class="keyword">int</span> axes, <span class="meta">@NestedScrollType</span> <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onNestedScrollAccepted</span><span class="params">(<span class="meta">@NonNull</span> View child, <span class="meta">@NonNull</span> View target, <span class="meta">@ScrollAxis</span> <span class="keyword">int</span> axes, <span class="meta">@NestedScrollType</span> <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onStopNestedScroll</span><span class="params">(<span class="meta">@NonNullView</span> target, <span class="meta">@NestedScrollType</span> <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(<span class="meta">@NonNull</span> View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed, <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, <span class="meta">@NestedScrollType</span> <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(<span class="meta">@NonNull</span> View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="meta">@NonNull</span> <span class="keyword">int</span>[] consumed, <span class="meta">@NestedScrollType</span> <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三版接口再一次添加了一个记录<code>已消耗的滑动距离</code>的参数</strong></p><p><strong>NestedScrollingChild3</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedScrollingChild3</span> <span class="keyword">extends</span> <span class="title">NestedScrollingChild2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchNestedScroll</span><span class="params">(<span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed, <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, <span class="meta">@Nullable</span> <span class="keyword">int</span>[] offsetInWindow, <span class="meta">@NestedScrollType</span> <span class="keyword">int</span> type, <span class="meta">@NonNull</span> <span class="keyword">int</span>[] consumed)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NestedScrollingParent3</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedScrollingParent3</span> <span class="keyword">extends</span> <span class="title">NestedScrollingParent2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(<span class="meta">@NonNull</span> View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed, <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, <span class="meta">@NestedScrollType</span> <span class="keyword">int</span> type, <span class="meta">@NonNull</span> <span class="keyword">int</span>[] consumed)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在自定义View时建议使用第三版的接口和辅助工具类（NestedScrollingParentHelper、NestedScrollingChildHelper）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nested-Scroll&quot;&gt;&lt;a href=&quot;#Nested-Scroll&quot; class=&quot;headerlink&quot; title=&quot;Nested Scroll&quot;&gt;&lt;/a&gt;Nested Scroll&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;当一个可滑动ViewGro</summary>
      
    
    
    
    
    <category term="Android" scheme="http://peceoqicka.github.io/project/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Touch事件分发学习笔记</title>
    <link href="http://peceoqicka.github.io/project/2019/12/06/android-source-touch/"/>
    <id>http://peceoqicka.github.io/project/2019/12/06/android-source-touch/</id>
    <published>2019-12-06T08:24:35.000Z</published>
    <updated>2020-01-19T07:03:30.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="窗口是Activity的容器"><a href="#窗口是Activity的容器" class="headerlink" title="窗口是Activity的容器"></a>窗口是Activity的容器</h2><p><strong>窗口（Window）</strong>接收用户的点击事件并逐步<strong>向内层传递</strong>，即<code>Window-&gt;Activity-&gt;ViewGroup-&gt;...-&gt;View</code></p><h2 id="dispatchTouchEvent、onInterceptTouchEvent与onTouchEvent"><a href="#dispatchTouchEvent、onInterceptTouchEvent与onTouchEvent" class="headerlink" title="dispatchTouchEvent、onInterceptTouchEvent与onTouchEvent"></a>dispatchTouchEvent、onInterceptTouchEvent与onTouchEvent</h2><ul><li><strong>dispatchTouchEvent</strong>负责事件分发，即事件由外向内传递事件的方法</li><li><strong>onInterceptTouchEvent</strong>是交给ViewGroup判断是否决定需要拦截事件（不让它的子View获取事件）的方法</li><li><strong>onTouchEvent</strong>是View（或ViewGroup）自身消费事件的方法</li></ul><h2 id="MotionEvent"><a href="#MotionEvent" class="headerlink" title="MotionEvent"></a>MotionEvent</h2><p>** MotionEvent**是对Touch事件的封装，MotionEvent主要包含以下事件类型：</p><ul><li>ACTION_DOWN（手指按下）</li><li>ACTION_MOVE （手指在屏幕上移动）</li><li>ACTION_UP （手指离开屏幕）</li><li>ACTION_CANCEL （特殊事件，事件被取消，通常为被父类拦截）</li></ul><h2 id="dispatchTouchEvent伪源码（简化版源码）"><a href="#dispatchTouchEvent伪源码（简化版源码）" class="headerlink" title="dispatchTouchEvent伪源码（简化版源码）"></a>dispatchTouchEvent伪源码（简化版源码）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在ACTION_DOWN时如果子类决定不处理事件</span></span><br><span class="line"><span class="comment">//（即child.dispatchTouchEvent返回false)</span></span><br><span class="line"><span class="comment">//那么后续事件将不再继续向内传递</span></span><br><span class="line"><span class="keyword">if</span> (ev.actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">clearStatus();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isDisallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) &#123;</span><br><span class="line">isSelfNeedEvent = <span class="keyword">true</span>;</span><br><span class="line">handled = onTouchEvent(ev);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">handled = child.dipatchTouchEvent(ev);</span><br><span class="line"><span class="keyword">if</span> (handled) isChildNeedEvent = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!handled) &#123;</span><br><span class="line">handled = onTouchEvent(ev);</span><br><span class="line"><span class="keyword">if</span> (handled) isSelfNeedEvent = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (isSelfNeedEvent) &#123;</span><br><span class="line">handled = onTouchEvent(ev);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!isDisallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) &#123;</span><br><span class="line">isSelfNeedEvent = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> cancel = MotionEvent.obtain(ev);</span><br><span class="line">cancel.action = MotionEvent.ACTION_CANCEL;</span><br><span class="line">handled = child.dispatchTouchEvent(cancel);</span><br><span class="line">cancel.recycle();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">handled = child.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ev.actionMasked == MotionEvent.ACTION_UP </span><br><span class="line">|| ev.actionMasked == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">clearStatus();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>isDisallowIntercept</strong>是ViewGroup的一个成员变量，在子类调用父类的<strong>requestDisallowInterceptTouchEvent</strong>方法时会改变它的值。</p><h2 id="onInterceptTouchEvent和requestDisallowInterceptTouchEvent"><a href="#onInterceptTouchEvent和requestDisallowInterceptTouchEvent" class="headerlink" title="onInterceptTouchEvent和requestDisallowInterceptTouchEvent"></a>onInterceptTouchEvent和requestDisallowInterceptTouchEvent</h2><p><strong>requestDisallowInterceptTouchEvent</strong>是子类在必要的时候用来告诉父类要不要拦截事件的方法。并且<strong>onInterceptTouchEvent</strong>会逐层向外传递。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;窗口是Activity的容器&quot;&gt;&lt;a href=&quot;#窗口是Activity的容器&quot; class=&quot;headerlink&quot; title=&quot;窗口是Activity的容器&quot;&gt;&lt;/a&gt;窗口是Activity的容器&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;窗口（Window）&lt;/st</summary>
      
    
    
    
    
    <category term="Android" scheme="http://peceoqicka.github.io/project/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>WheelLayoutManager——自定义轮式选择器布局</title>
    <link href="http://peceoqicka.github.io/project/2019/08/27/wheellayoutmanager/"/>
    <id>http://peceoqicka.github.io/project/2019/08/27/wheellayoutmanager/</id>
    <published>2019-08-27T02:12:37.000Z</published>
    <updated>2019-08-28T03:16:21.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>轮式选择器，顾名思义，就是像滚轮一样的选择器。在老式的Android系统上，曾经有过轮式选择器样式的<strong>DatePicker</strong>（如下图）。</p><p>优点是系统封装好的，直接调用即可，缺点就是样式不好定制（例如我想改选中线的颜色长度，改选中文字的颜色字号大小什么的）。即使他提供有相应的修改接口，定制起来也是相当的麻烦。我也想过通过自定义View的方式来实现，但是苦于一直没办法做出无限循环的效果，另外即使自定义View，也同样会有自定义样式麻烦的问题。</p><h2 id="是否没有办法了呢？"><a href="#是否没有办法了呢？" class="headerlink" title="是否没有办法了呢？"></a>是否没有办法了呢？</h2><p><strong>当然不是！</strong>直到我遇到Google的天才程序员们设计出的一个全新的控件[RecyclerView](<a href="https://developer.android.com/guide/topics/ui/layout/recyclerview">https://developer.android.com/guide/topics/ui/layout/recyclerview</a> 需要全球互联网)。它能代替几乎所有的适配器型容器控件(ListView, GridView等)，更能更自由的定制子元素样式（通过自定义ItemDecoration），它使得列表的布局方式定制更容易，仅仅需要自定义<strong>LayoutManager</strong>即可。</p><h2 id="有请主角LayoutManager登场"><a href="#有请主角LayoutManager登场" class="headerlink" title="有请主角LayoutManager登场"></a>有请主角LayoutManager登场</h2><p><strong>LayoutManager</strong>是RecyclerView最重要的合作伙伴，通过切换LayoutManager，可以瞬间从ListView变成GridView，或者变成其他样子。正因为这样的高度可变性才使得实现真正好用的轮式选择器成为了可能。废话不多说，开始吧。</p><h1 id="WheelLayoutManager"><a href="#WheelLayoutManager" class="headerlink" title="WheelLayoutManager"></a>WheelLayoutManager</h1><p>首先我还是要感谢 <strong>陈小缘</strong> 写的这篇文章 <a href="http://www.10tiao.com/html/227/201810/2650244339/1.html">《看完让你直呼666的自定义LayoutManager之旅》</a> 为我实现<strong>WheelLayoutManager</strong>提供了思路。</p><p>自定义LayoutManager与自定义ViewGroup有许多共通之处，基本流程也是一致的：测量、布局、刷新（滚动）。</p><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>不过首先，我们还是要来做一个需求分析，对于轮式选择器，需要实现以下功能：</p><ol><li>第一个元素垂直居中于控件，其余的按顺序往后排列</li><li>居中的元素高亮效果</li><li>居中的元素旁边添加一些装饰元素</li><li>滑动到某两个元素中间时，自动滚动到某个元素居中（即选中效果）</li><li>无限循环</li></ol><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><p>这个其实很简单，后续的功能都要以此为基础。因为要考虑滑动的问题，所以需要设置一个变量<strong>scrollOffsetY</strong>来记录当前的偏移值。当<code>scrollOffsetY = 0</code>的时候，第一个元素垂直居中于控件。我们考虑设置一个基本参数<strong>visibleCount</strong>，即轮式选择器当中可显示的元素个数，假定为5。</p><p>如图，假定每个元素的高度为一致的<code>140px</code>，整个控件的高度为<code>5 x 140 = 700 px</code>，那么第一个元素的顶部坐标即为 <code>2 x 140 = 280 px</code>，此时定为scrollOffsetY = 0。（且不考虑无限循环模式）</p><p>这里需要算出一个元素的布局位置计算公式（顶部），在布局时带入当前的<code>偏移值</code>和元素的<code>index</code>即可算出特定的元素的布局位置。将前边所说的数值考虑进来，当scrollOffsetY=0时index为0的元素位置为280px，index为1的元素位置为420px，……由此可以类推出如下的通用公式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定Item在特定scrollOffsetY值时的顶部位置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index Item在适配器中的Index值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLayoutTop</span><span class="params">(index: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> index * requiredItemHeight + requiredMarginTop - scrollOffsetY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>requiredItemHeight：元素高度（140px）</li><li>requiredMarginTop：第一个元素居中所需要的距离（280px）</li></ul><h3 id="重要的全局参数"><a href="#重要的全局参数" class="headerlink" title="重要的全局参数"></a>重要的全局参数</h3><p>说到这几个全局参数，不得不把剩下的几个参数也在这里全部说明：</p><ul><li>visibleCount：可见的元素个数，作为构造函数参数传进来的，必须为大于等于3的奇数，否则就没有任何意义（暂不考虑其他情况）</li><li>requiredSpaceCount：第一个元素垂直居中所需要补充的空白元素的个数，这里可见元素为5，因此这里需要的数量为2，至于计算公式：<code>requiredSpaceCount = (visibleCount - 1) /2 </code></li><li>requiredItemHeight：这里我们要求每个元素的高度相同，当我们只限定RecyclerView的高度的时候，就需要计算这个值：<code>requiredItemHeight = height / visibleCount</code></li><li>requiredMarginTop：第一个元素垂直居中需要补充的空白元素的总高度，这里需要补充2个空白元素，所以总高度为280px，计算公式：<code>requiredMarginTop = requiredItemHeight * requiredSpaceCount</code></li></ul><h3 id="布局所有元素"><a href="#布局所有元素" class="headerlink" title="布局所有元素"></a>布局所有元素</h3><p>说完了重要参数，布局位置计算公式也有了，那么接下来就该布局代码上场了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLayoutChildren</span><span class="params">(recycler: <span class="type">RecyclerView</span>.<span class="type">Recycler</span>, state: <span class="type">RecyclerView</span>.<span class="type">State</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (state.itemCount == <span class="number">0</span>) &#123;</span><br><span class="line">        removeAndRecycleAllViews(recycler)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    calculateParams()</span><br><span class="line">    <span class="comment">//暂时分离和回收全部有效的Item</span></span><br><span class="line">    detachAndScrapAttachedViews(recycler)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state.itemCount &gt; ((visibleCount + <span class="number">1</span>) / <span class="number">2</span>)) &#123;</span><br><span class="line">        canScrollVertically = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    layoutChildren(recycler, state)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的**layoutChildren()**方法不止在这里用得到，这是关键的方法，但是本质上也不复杂。在布局之前一定要通过<code>detachAndScrapAttachedViews(recycler)</code>暂时分离和回收全部有效元素，然后再布局：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">layoutChildren</span><span class="params">(recycler: <span class="type">RecyclerView</span>.<span class="type">Recycler</span>, state: <span class="type">RecyclerView</span>.<span class="type">State</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> (headIndex, tailIndex) = getLayoutRange(state.itemCount)</span><br><span class="line">    posLayoutHead = <span class="keyword">if</span> (headIndex &gt;= <span class="number">0</span>) headIndex <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    posLayoutTail = <span class="keyword">if</span> (tailIndex &gt;= <span class="number">0</span>) tailIndex <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (headIndex &gt;= <span class="number">0</span> &amp;&amp; tailIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> (headIndex..tailIndex)) &#123;</span><br><span class="line">            <span class="keyword">val</span> child = getItemView(recycler, i)</span><br><span class="line">            <span class="keyword">val</span> decoratedWidth = getDecoratedMeasuredWidth(child)</span><br><span class="line">            <span class="keyword">val</span> childTop = getLayoutTop(i)</span><br><span class="line">            <span class="keyword">val</span> childBottom = childTop + getDecoratedMeasuredHeight(child)</span><br><span class="line">            layoutDecorated(child, <span class="number">0</span>, childTop, decoratedWidth, childBottom)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">val</span> removalList = ArrayList&lt;RecyclerView.ViewHolder&gt;()</span><br><span class="line">    removalList.addAll(recycler.scrapList)</span><br><span class="line">    removalList.forEach &#123; holder -&gt;</span><br><span class="line">        removeView(holder.itemView)</span><br><span class="line">        recycler.recycleView(holder.itemView)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据scrollOffsetY计算出布局的范围：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLayoutRange</span><span class="params">(itemCount: <span class="type">Int</span>)</span></span>: Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> headIndex = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> tailIndex = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> (<span class="number">0</span> until itemCount)) &#123;</span><br><span class="line">        <span class="keyword">val</span> childTop = getLayoutTop(i)</span><br><span class="line">        <span class="keyword">val</span> childBottom = childTop + requiredItemHeight</span><br><span class="line">        <span class="keyword">if</span> (isLayoutInVisibleArea(childTop, childBottom)) &#123;</span><br><span class="line">            headIndex = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> (headIndex + <span class="number">1</span> until itemCount)) &#123;</span><br><span class="line">        <span class="keyword">val</span> childTop = getLayoutTop(i)</span><br><span class="line">        <span class="keyword">if</span> (childTop &gt; height) &#123;</span><br><span class="line">            tailIndex = i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tailIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        tailIndex = itemCount - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> headIndex to tailIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>布局完成后，从<strong>recycler</strong>的“废品列表”（<strong>scrapList</strong>）中拿出要回收的View，全部移除和回收掉。还记得刚才的<code>detachAndScrapAttachedViews(recycler)</code>吗？所有分离和回收的都会暂时放到这里的scrapList中，而布局时获取View也是优先从这里取出“原料”，因此，布局完成后彻底回收时，从scrapList中找出所有的View移除和回收即可。至此，布局所有元素的任务便完成了。</p><h3 id="让元素动起来"><a href="#让元素动起来" class="headerlink" title="让元素动起来"></a>让元素动起来</h3><p>当你在屏幕上放上你的手指，然后拖动时，会触发回调方法<strong>scrollVerticallyBy</strong>，在这个方法中，需要更新<strong>偏移值</strong>，然后<strong>重新布局元素</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">scrollVerticallyBy</span><span class="params">(dy: <span class="type">Int</span>, recycler: <span class="type">RecyclerView</span>.<span class="type">Recycler</span>, state: <span class="type">RecyclerView</span>.<span class="type">State</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">//&lt;0 :手指往下滑  &gt;0 :手指往上滑</span></span><br><span class="line">    <span class="keyword">if</span> (state.itemCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    calculateParams()</span><br><span class="line">    detachAndScrapAttachedViews(recycler)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> lastOffset = scrollOffsetY</span><br><span class="line">    updateScrollOffsetY(dy, lastOffset, state.itemCount)</span><br><span class="line">    <span class="comment">//重新布局</span></span><br><span class="line">    layoutChildren(recycler, state)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (lastOffset == scrollOffsetY) <span class="number">0</span> <span class="keyword">else</span> dy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你是否注意到，LinearLayoutManager滑动到边界（第一个元素或最后一个元素）时有个回弹效果，不用担心，回弹效果不需要我们来实现，我们只需要计算好<strong>最大偏移值和最小偏移值</strong>即可。因为要实现垂直居中功能，前边我们计算了第一个元素垂直居中时，第一个元素距离顶部的位置（280px），那如果滑动到最后一个元素垂直居中时呢？也是一样的道理，最后一个元素的下边就需要2个元素的“补白”（也是280px），这样的效果需要设置一个溢出值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateScrollOffsetY</span><span class="params">(dy: <span class="type">Int</span>, lastOffsetY: <span class="type">Int</span>, itemCount: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    scrollOffsetY += dy</span><br><span class="line">    <span class="keyword">val</span> childrenHeight = itemCount * requiredItemHeight</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">val</span> maxOverflowHeight = childrenHeight - requiredItemHeight</span><br><span class="line">    <span class="keyword">if</span> (scrollOffsetY &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        scrollOffsetY = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scrollOffsetY &gt; maxOverflowHeight) &#123;</span><br><span class="line">        scrollOffsetY = <span class="keyword">if</span> (maxOverflowHeight &gt; <span class="number">0</span>) maxOverflowHeight <span class="keyword">else</span> lastOffsetY</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>往下滑自然不必多说，当滑到小于0的位置时，强制把偏移值设置为0，那么滑动到顶部就不能继续再往下滑了。往上滑滑动最后一个元素居中时，根据前边算出的顶部距离公式（getLayoutTop），带入最后一个元素的Index值，这里设scrollOffsetY为x：</p><blockquote><p>$$ (itemCount - 1) * requiredItemHeight  + requiredMarginTop - x = requiredMarginTop $$</p></blockquote><p>计算出最大偏移值：</p><blockquote><p>$$ x = itemCount * requiredItemHeight -requiredItemHeight $$</p></blockquote><p>重新布局元素，直接再调用**layoutChildren(recycler, state)**即可，没有任何区别。</p><h2 id="选中效果，居中元素装饰，居中元素高亮"><a href="#选中效果，居中元素装饰，居中元素高亮" class="headerlink" title="选中效果，居中元素装饰，居中元素高亮"></a>选中效果，居中元素装饰，居中元素高亮</h2><p>之所以我要把这3个功能放到一起，因为元素装饰和元素高亮是以选中效果为基础的。怎么做选中效果呢，根据我们的设计，只有当scrollOffsetY的值为一些特定的值的时候（280px，420px，560px，……），元素的布局才会呈现给我们一种居中选中的特殊视觉效果。</p><p>所以滑动到某个偏移值的时候，可以计算出这个值最接近的某元素居中所需要的偏移值，然后通过动画，滑动到这个特定偏移值。</p><h3 id="选中效果"><a href="#选中效果" class="headerlink" title="选中效果"></a>选中效果</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findClosestItemPosition</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> estimatedPosition = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> minDistance = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> (<span class="number">0</span> until itemCount)) &#123;</span><br><span class="line">        <span class="keyword">val</span> distance = Math.abs(getRequiredScrollOffset(i) - scrollOffsetY)</span><br><span class="line">        <span class="keyword">if</span> (distance &lt; minDistance) &#123;</span><br><span class="line">            minDistance = distance</span><br><span class="line">            estimatedPosition = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> estimatedPosition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定position的Item选中时对应的ScrollOffset值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getRequiredScrollOffset</span><span class="params">(targetPosition: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> targetPosition * requiredItemHeight</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>滑动停止时调用，然后生成动画并执行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onScrollStateChanged</span><span class="params">(state: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onScrollStateChanged(state)</span><br><span class="line">    <span class="keyword">when</span> (state) &#123;</span><br><span class="line">        RecyclerView.SCROLL_STATE_DRAGGING -&gt; &#123;</span><br><span class="line">            draggingStartListener?.invoke()</span><br><span class="line">            stopScrollAnimation()</span><br><span class="line">        &#125;</span><br><span class="line">        RecyclerView.SCROLL_STATE_IDLE -&gt; &#123;</span><br><span class="line">            startScrollAnimation(findClosestItemPosition(), itemCount)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">startScrollAnimation</span><span class="params">(position: <span class="type">Int</span>, itemCount: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    stopScrollAnimation()</span><br><span class="line">    <span class="keyword">val</span> scrollDistance = (getRequiredScrollOffset(position) - scrollOffsetY)</span><br><span class="line">    <span class="comment">//既然定位都是Int，那动画值的变化也要用Int，用Float就会出现滑动停止后偏离几个像素的尴尬场面</span></span><br><span class="line">    scrollValueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, scrollDistance).setDuration(<span class="number">300</span>)</span><br><span class="line">    scrollValueAnimator.addUpdateListener(ScrollAnimatorUpdateListener &#123; deltaValue -&gt;</span><br><span class="line">        updateScrollOffsetY(deltaValue, scrollOffsetY, itemCount)</span><br><span class="line">        requestLayout()</span><br><span class="line">    &#125;)</span><br><span class="line">    scrollValueAnimator.addListener(<span class="keyword">object</span> : AnimatorListenerProxy() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationEnd</span><span class="params">(animation: <span class="type">Animator</span>)</span></span> &#123;</span><br><span class="line">            selectedPosition = position</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    scrollValueAnimator.start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ScrollAnimatorUpdateListener</span></span>(<span class="keyword">val</span> valueUpdated: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span>) :</span><br><span class="line">    ValueAnimator.AnimatorUpdateListener &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> lastValue: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationUpdate</span><span class="params">(animation: <span class="type">ValueAnimator</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> currentValue = animation.animatedValue <span class="keyword">as</span> <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">if</span> (currentValue != <span class="number">0</span>) &#123;</span><br><span class="line">            valueUpdated(currentValue - lastValue)</span><br><span class="line">        &#125;</span><br><span class="line">        lastValue = currentValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="居中元素高亮"><a href="#居中元素高亮" class="headerlink" title="居中元素高亮"></a>居中元素高亮</h3><p>本质上还是依托于选中效果，还记得前边我们用一个全局变量<strong>selectedPosition</strong>记录了选中的元素吗，同时暴露了一个回调方法<strong>selectionChangedListener</strong>给外界，在外界调用更新：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">yearLayoutManager = WheelLayoutManager(<span class="number">5</span>).apply &#123;</span><br><span class="line">    selectionChangedListener = <span class="keyword">this</span><span class="symbol">@MainActivity</span>::onYearSelectionChanged</span><br><span class="line">    draggingStartListener = &#123;</span><br><span class="line">        deselectIndex(yearAdapter)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onYearSelectionChanged</span><span class="params">(position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> selectedValue = bindModel.yearAdapter?.getValue(position) ?: -<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (selectedValue &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        selectedYear = selectedValue</span><br><span class="line">        onDayChanged()</span><br><span class="line">        <span class="comment">//选中元素，导致元素的文字颜色等发生变化</span></span><br><span class="line">        selectIndex(bindModel.yearAdapter, position)</span><br><span class="line">        bindModel.yearDisplay = selectedYear</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我使用了<strong>DataBinding</strong>来实现高亮效果，不过多描述，建议看源码（源码地址在文末）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@&#123;@string/int_to_str(model.value)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">&quot;@&#123;model.selected ? @color/hex_db262e : @color/hex_9c9c9c&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">&quot;@dimen/px_53&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="居中元素装饰"><a href="#居中元素装饰" class="headerlink" title="居中元素装饰"></a>居中元素装饰</h3><p>比如这里做的日历选择器，要添加背景颜色，高亮区域背景颜色，以及其他装饰性图案，都需要一个坐标，在LayoutManager中将计算好的相关参数暴露给外界即可。然后自定义<strong>ItemDecoration</strong>来实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 居中的item的上边距</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">val</span> selectionTop: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = requiredMarginTop</span><br><span class="line"><span class="keyword">val</span> itemHeight: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = requiredItemHeight</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DateItemDecoration</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDrawOver</span><span class="params">(c: <span class="type">Canvas</span>, parent: <span class="type">RecyclerView</span>, state: <span class="type">RecyclerView</span>.<span class="type">State</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//取得WheelLayoutManager</span></span><br><span class="line">    <span class="keyword">val</span> layoutManager = parent.layoutManager <span class="keyword">as</span>? WheelLayoutManager ?: <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">val</span> highlightLineTop = layoutManager.selectionTop + <span class="number">0f</span></span><br><span class="line">    <span class="keyword">val</span> highlightLineBottom = highlightLineTop + layoutManager.itemHeight + <span class="number">0f</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> parentWidth = parent.width + <span class="number">0f</span></span><br><span class="line">    <span class="keyword">val</span> parentHeight = parent.height + <span class="number">0f</span></span><br><span class="line">    <span class="comment">//绘制高亮区域的边界线</span></span><br><span class="line">    c.drawLine(<span class="number">0f</span>, <span class="number">0f</span>, parentWidth, <span class="number">0f</span>, highlightLinePaint)</span><br><span class="line">    c.drawLine(<span class="number">0f</span>, highlightLineTop, parentWidth, highlightLineTop, highlightLinePaint)</span><br><span class="line">    c.drawLine(<span class="number">0f</span>, highlightLineBottom, parentWidth, highlightLineBottom, highlightLinePaint)</span><br><span class="line">    c.drawLine(<span class="number">0f</span>, parentHeight, parentWidth, parentHeight, highlightLinePaint)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enableHighlightMarker) &#123;</span><br><span class="line">        <span class="comment">//绘制高亮标记线</span></span><br><span class="line">        c.drawRect(</span><br><span class="line">            <span class="number">0f</span>, highlightLineTop, highlightMarkerWidth.toFloat(),</span><br><span class="line">            highlightLineBottom, highlightMarkerPaint</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (enableHintText) &#123;</span><br><span class="line">        <span class="keyword">val</span> textY = highlightLineTop + layoutManager.itemHeight / <span class="number">2</span> + hintTextDrawingOffsetY</span><br><span class="line">        <span class="keyword">val</span> textX = parent.width - hintTextPaint.measureText(hintText) - hintTextRightMargin</span><br><span class="line">        <span class="comment">//绘制年月日文字</span></span><br><span class="line">        c.drawText(hintText, textX, textY, hintTextPaint)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他就不贴代码了，请参考源码。</p><h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><p>标准模式下的实现相对容易，如图</p><p>但是无限循环，乍看之下不知道从何下手，既然如此，那干脆先把图画出来，再来分析。</p><h3 id="补充布局"><a href="#补充布局" class="headerlink" title="补充布局"></a>补充布局</h3><p>如图，普通模式第一个元素是1，从上往下依次是1<del>3，1的上边应该是最后一个元素31，再往上是30、29、……。所以说无限循环的本质就是头接尾、尾接头。<br>先考虑<code>scrollOffsetY = 0</code>的情况，上图即是，1</del>3的布局保持不变，重点是1上边的31、30。我姑且把它们称之为<strong>负序列布局</strong>，把之前的<code>layoutChildren</code>方法稍微修改一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">layoutChildren</span><span class="params">(recycler: <span class="type">RecyclerView</span>.<span class="type">Recycler</span>, state: <span class="type">RecyclerView</span>.<span class="type">State</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//正序列布局</span></span><br><span class="line">    <span class="keyword">val</span> (headIndex, tailIndex) = getLayoutRange(state.itemCount)</span><br><span class="line">    posLayoutHead = <span class="keyword">if</span> (headIndex &gt;= <span class="number">0</span>) headIndex <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    posLayoutTail = <span class="keyword">if</span> (tailIndex &gt;= <span class="number">0</span>) tailIndex <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (headIndex &gt;= <span class="number">0</span> &amp;&amp; tailIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> (headIndex..tailIndex)) &#123;</span><br><span class="line">            <span class="keyword">val</span> child = getItemView(recycler, i)</span><br><span class="line">            <span class="keyword">val</span> decoratedWidth = getDecoratedMeasuredWidth(child)</span><br><span class="line">            <span class="keyword">val</span> childTop = getLayoutTop(i)</span><br><span class="line">            <span class="keyword">val</span> childBottom = childTop + getDecoratedMeasuredHeight(child)</span><br><span class="line">            layoutDecorated(child, <span class="number">0</span>, childTop, decoratedWidth, childBottom)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//负序列布局</span></span><br><span class="line">    <span class="keyword">if</span> (isInfiniteScrollEnabled(state.itemCount)) &#123;</span><br><span class="line">        <span class="keyword">val</span> (negHeadIndex, negTailIndex) = getNegativeLayoutRange(state.itemCount)</span><br><span class="line">        negLayoutHead = <span class="keyword">if</span> (negHeadIndex &gt;= <span class="number">0</span>) negHeadIndex <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        negLayoutTail = <span class="keyword">if</span> (negTailIndex &gt;= <span class="number">0</span>) negTailIndex <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (negHeadIndex &gt;= <span class="number">0</span> &amp;&amp; negTailIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> (negTailIndex downTo negHeadIndex)) &#123;</span><br><span class="line">                <span class="keyword">val</span> child = getItemView(recycler, i)</span><br><span class="line">                <span class="keyword">val</span> decoratedWidth = getDecoratedMeasuredWidth(child)</span><br><span class="line">                <span class="keyword">val</span> childTop = getNegativeLayoutTop(i, state.itemCount)</span><br><span class="line">                <span class="keyword">val</span> childBottom = childTop + getDecoratedMeasuredHeight(child)</span><br><span class="line">                layoutDecorated(child, <span class="number">0</span>, childTop, decoratedWidth, childBottom)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> removalList = ArrayList&lt;RecyclerView.ViewHolder&gt;()</span><br><span class="line">    removalList.addAll(recycler.scrapList)</span><br><span class="line">    removalList.forEach &#123; holder -&gt;</span><br><span class="line">        removeView(holder.itemView)</span><br><span class="line">        recycler.recycleView(holder.itemView)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算负序列布局的布局范围：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getNegativeLayoutRange</span><span class="params">(itemCount: <span class="type">Int</span>)</span></span>: Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> headIndex = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> tailIndex = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> (itemCount - <span class="number">1</span> downTo <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">val</span> childTop = getNegativeLayoutTop(i, itemCount)</span><br><span class="line">        <span class="keyword">val</span> childBottom = childTop + requiredItemHeight</span><br><span class="line">        <span class="keyword">if</span> (isLayoutInVisibleArea(childTop, childBottom)) &#123;</span><br><span class="line">            tailIndex = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> (tailIndex - <span class="number">1</span> downTo <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">val</span> childTop = getNegativeLayoutTop(i, itemCount)</span><br><span class="line">        <span class="keyword">val</span> childBottom = childTop + requiredItemHeight</span><br><span class="line">        <span class="keyword">if</span> (childBottom &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            headIndex = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (headIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        headIndex = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> headIndex to tailIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要一个负序列位置计算公式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定Item在特定scrollOffsetY值时的顶部位置(负序列定位规则)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index Item在适配器中的Index值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> itemCount 适配器中的itemCount</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getNegativeLayoutTop</span><span class="params">(index: <span class="type">Int</span>, itemCount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (requiredSpaceCount - <span class="number">1</span>) * requiredItemHeight - scrollOffsetY - (itemCount - <span class="number">1</span> - index) * requiredItemHeight</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个负序列位置计算就不能再依靠之前的位置公式了，因为负序列采用了不同的定位方式：<strong>从下往上</strong>。从最后一个元素开始，往前布局。还是采用前边的假设，所以31的顶部位置为140px，30的位置为0px，29的位置为-140px。由此可以推算出上述的计算公式。</p><h3 id="偏移值临界点"><a href="#偏移值临界点" class="headerlink" title="偏移值临界点"></a>偏移值临界点</h3><p>初步的布局已经成功了，接下来就该让它动起来了。如果我手指拖动往下滑，滑到scrollOffsetY &lt; 0 还继续往下滑，当滑动了一圈之后发现，<strong>咦？怎么上边没了？</strong></p><p>别着急，我们分析一下为什么没了？看看Logcat，这个时候的scrollOffsetY值大概已经是-18xx了吧。往下滑，当前布局的就是负序列，再往前，负序列前边却没办法再补充一个负序列了，所以才会出现没了。同理，如果你往上滑，滑动到正序列的尾部的时候，也会没了，正序列后边不可能再补充一个正序列。说到这里，你可能会问我，<strong>那可怎么办？</strong></p><p>其实答案很简单，我们需要处理一下<strong>scrollOffsetY</strong>的值，限定它的范围。先来看看一个临界点位置：</p><p>如图，可见区域的元素是<code>27、28、29、30、31</code>，这时候scrollOffsetY的值是多少？答案是有两种可能，-420px或者3920px，往下滑-420px（完全布局负序列），往上滑3920px（完全布局正序列）。也就是说，无论当前是-420px还是3920px，我们看到的元素排列样子完全相同。</p><p><strong>那么，用这两个数值作为scrollOffsetY的范围能行吗？</strong></p><p>答案是肯定的，如果scrollOffsetY的值大于3920px，就强制变为大于-420px的数；小于-420px，就强制变为小于3920px的数。 分别根据正负序列位置计算公式，算出正负阈值。稍微修改一下**updateScrollOffsetY()**方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateScrollOffsetY</span><span class="params">(dy: <span class="type">Int</span>, lastOffsetY: <span class="type">Int</span>, itemCount: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    scrollOffsetY += dy</span><br><span class="line">    <span class="keyword">val</span> childrenHeight = itemCount * requiredItemHeight</span><br><span class="line">    <span class="keyword">if</span> (isInfiniteScrollEnabled(itemCount)) &#123;</span><br><span class="line">        <span class="keyword">val</span> negLenThreshold = (requiredSpaceCount + <span class="number">1</span>) * requiredItemHeight</span><br><span class="line">        <span class="keyword">val</span> posLenThreshold = childrenHeight - negLenThreshold</span><br><span class="line">        <span class="keyword">val</span> mod = scrollOffsetY % requiredItemHeight</span><br><span class="line">        <span class="keyword">if</span> (scrollOffsetY &gt; posLenThreshold) &#123;</span><br><span class="line">            scrollOffsetY = -negLenThreshold + mod</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scrollOffsetY &lt;= -negLenThreshold) &#123;</span><br><span class="line">            scrollOffsetY = posLenThreshold - mod</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> maxOverflowHeight = childrenHeight - requiredItemHeight</span><br><span class="line">        <span class="keyword">if</span> (scrollOffsetY &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            scrollOffsetY = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scrollOffsetY &gt; maxOverflowHeight) &#123;</span><br><span class="line">            scrollOffsetY = <span class="keyword">if</span> (maxOverflowHeight &gt; <span class="number">0</span>) maxOverflowHeight <span class="keyword">else</span> lastOffsetY</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，真正的无限循环便实现了。</p><h3 id="修改选中效果"><a href="#修改选中效果" class="headerlink" title="修改选中效果"></a>修改选中效果</h3><p>虽然无限循环的效果是实现了，但还有一个工作需要完成：选中效果只做了普通模式，无限循环模式的选中效果还需要修改。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createScrollAnimation</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//如果是无限循环模式，则在判断选中位置时需要考虑scrollOffset分界点的问题</span></span><br><span class="line">    <span class="keyword">if</span> (isInfiniteScrollEnabled(itemCount)) &#123;</span><br><span class="line">        <span class="keyword">val</span> negLenThreshold = (requiredSpaceCount + <span class="number">1</span>) * requiredItemHeight</span><br><span class="line">        <span class="keyword">val</span> posLenThreshold = itemCount * requiredItemHeight - negLenThreshold</span><br><span class="line">        <span class="keyword">val</span> criticalValue = -requiredItemHeight / <span class="number">2</span></span><br><span class="line">        <span class="keyword">var</span> targetPosition = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> minDistance = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">        <span class="keyword">if</span> (scrollOffsetY &gt; -negLenThreshold &amp;&amp; scrollOffsetY &lt; criticalValue) &#123;</span><br><span class="line">            <span class="comment">//正负序列混合布局区域</span></span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> (negLayoutTail downTo negLayoutHead)) &#123;</span><br><span class="line">                <span class="keyword">val</span> distance = Math.abs(getRequiredScrollOffset(i) - scrollOffsetY)</span><br><span class="line">                <span class="keyword">if</span> (distance &lt; minDistance) &#123;</span><br><span class="line">                    minDistance = distance</span><br><span class="line">                    targetPosition = i</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (targetPosition &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               targetPosition = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scrollOffsetY <span class="keyword">in</span> criticalValue..posLenThreshold) &#123;</span><br><span class="line">            <span class="comment">//纯正序列布局区域</span></span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> (posLayoutHead..posLayoutTail)) &#123;</span><br><span class="line">                <span class="keyword">val</span> distance = Math.abs(getRequiredScrollOffset(i) - scrollOffsetY)</span><br><span class="line">                <span class="keyword">if</span> (distance &lt; minDistance) &#123;</span><br><span class="line">                    minDistance = distance</span><br><span class="line">                    targetPosition = i</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        startScrollAnimation(targetPosition, itemCount)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        startScrollAnimation(findClosestItemPosition(), itemCount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改获取特定偏移值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getRequiredScrollOffset</span><span class="params">(targetPosition: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (scrollOffsetY &gt;= -requiredItemHeight / <span class="number">2</span>) &#123;</span><br><span class="line">        targetPosition * requiredItemHeight</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        -(itemCount - targetPosition) * requiredItemHeight</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="适配元素数量变化"><a href="#适配元素数量变化" class="headerlink" title="适配元素数量变化"></a>适配元素数量变化</h2><p>基本功能都已经全部实现了，但还有最后一项不可忽视的工作：适配元素数量变化。当元素数量产生变化时，同时必然会导致布局产生变化，然后会引起选中元素变化。适配需要复写的方法主要有两个：<strong>onItemsAdded</strong>和<strong>onItemsRemoved</strong>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onItemsAdded</span><span class="params">(recyclerView: <span class="type">RecyclerView</span>, positionStart: <span class="type">Int</span>, itemCount: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onItemsAdded(recyclerView, positionStart, itemCount)</span><br><span class="line">    fixSelection(positionStart, itemCount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onItemsRemoved</span><span class="params">(recyclerView: <span class="type">RecyclerView</span>, positionStart: <span class="type">Int</span>, itemCount: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onItemsRemoved(recyclerView, positionStart, itemCount)</span><br><span class="line">    fixSelection(positionStart, -itemCount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">fixSelection</span><span class="params">(positionStart: <span class="type">Int</span>, changeLength: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> positionEnd = positionStart + Math.abs(changeLength)</span><br><span class="line">    <span class="keyword">var</span> newPosition = selectedPosition</span><br><span class="line">    <span class="keyword">if</span> (changeLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        <span class="keyword">if</span> (selectedPosition &gt;= positionEnd) &#123;</span><br><span class="line">            newPosition += Math.abs(changeLength)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (changeLength &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//删除元素</span></span><br><span class="line">        <span class="keyword">if</span> (selectedPosition <span class="keyword">in</span> (positionStart until positionEnd)) &#123;</span><br><span class="line">            newPosition = <span class="keyword">if</span> (itemCount - <span class="number">1</span> - positionEnd &gt; positionStart) &#123;</span><br><span class="line">                positionEnd</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                positionStart - <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectedPosition &gt;= positionEnd) &#123;</span><br><span class="line">            newPosition -= Math.abs(changeLength)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修正由于Item数量产生变化而scrollOffsetY越界没有重新计算的问题</span></span><br><span class="line">    updateScrollOffsetY(<span class="number">0</span>, <span class="number">0</span>, itemCount)</span><br><span class="line">    scrollToPosition(newPosition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p><a href="https://github.com/peceoqicka/WheelLayoutManager">源码地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;轮式选择器，顾名思义，就是像滚轮一样的选择器。在老式的Android系统上，曾经有过轮式选择器样式的&lt;strong&gt;DatePicker&lt;/</summary>
      
    
    
    
    
    <category term="Android" scheme="http://peceoqicka.github.io/project/tags/Android/"/>
    
    <category term="Kotlin" scheme="http://peceoqicka.github.io/project/tags/Kotlin/"/>
    
    <category term="RecyclerView" scheme="http://peceoqicka.github.io/project/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>记JavaFx中的那些坑</title>
    <link href="http://peceoqicka.github.io/project/2018/07/27/javafx-2-trap/"/>
    <id>http://peceoqicka.github.io/project/2018/07/27/javafx-2-trap/</id>
    <published>2018-07-27T01:43:35.000Z</published>
    <updated>2018-07-27T07:01:36.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WebView加载相对路径下的HTML页面"><a href="#WebView加载相对路径下的HTML页面" class="headerlink" title="WebView加载相对路径下的HTML页面"></a>WebView加载相对路径下的HTML页面</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webview.engine.load(javaClass.getResource(<span class="string">&quot;web/index.html&quot;</span>).toExternalForm())</span><br></pre></td></tr></table></figure><p>重点在于<code>toExternalForm()</code>方法</p><h2 id="WebView添加Javascript交互接口"><a href="#WebView添加Javascript交互接口" class="headerlink" title="WebView添加Javascript交互接口"></a>WebView添加Javascript交互接口</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">webview.engine.loadWorker.stateProperty()</span><br><span class="line">                .addListener &#123; _: ObservableValue&lt;<span class="keyword">out</span> Worker.State&gt;, _: Worker.State, newValue: Worker.State -&gt;</span><br><span class="line">                    <span class="keyword">if</span> (newValue == Worker.State.SUCCEEDED) &#123;</span><br><span class="line">                        <span class="keyword">val</span> win = wvContent.engine.executeScript(<span class="string">&quot;window&quot;</span>) <span class="keyword">as</span> JSObject</span><br><span class="line">                        win.setMember(<span class="string">&quot;app&quot;</span>, AppEnv())</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>在HTML页面中调用Java端代码应该调用<code>app.doSomething()</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">AppEnv</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebView添加样式"><a href="#WebView添加样式" class="headerlink" title="WebView添加样式"></a>WebView添加样式</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webview.engine.userStyleSheetLocation = javaClass.getResource(<span class="string">&quot;scrollbar_style.css&quot;</span>).toExternalForm()</span><br></pre></td></tr></table></figure><p><code>scrollbar_style.css</code>是相对此代码文件同一目录下的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;WebView加载相对路径下的HTML页面&quot;&gt;&lt;a href=&quot;#WebView加载相对路径下的HTML页面&quot; class=&quot;headerlink&quot; title=&quot;WebView加载相对路径下的HTML页面&quot;&gt;&lt;/a&gt;WebView加载相对路径下的HTML页面&lt;/</summary>
      
    
    
    
    
    <category term="Java" scheme="http://peceoqicka.github.io/project/tags/Java/"/>
    
    <category term="JavaFx" scheme="http://peceoqicka.github.io/project/tags/JavaFx/"/>
    
  </entry>
  
  <entry>
    <title>Electron学习笔记（二）：UI开发</title>
    <link href="http://peceoqicka.github.io/project/2018/07/12/electron-2/"/>
    <id>http://peceoqicka.github.io/project/2018/07/12/electron-2/</id>
    <published>2018-07-12T06:35:57.000Z</published>
    <updated>2018-07-12T06:55:26.593Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>UI开发由于使用的是HTML、CSS、Javascript，所以以前怎么来，现在还是怎么来，你甚至可以使用以前用的习惯的各种框架：<code>Angular</code>、<code>Bootstrap</code>、<code>JQuery</code>等等</p></blockquote><p>你可以使用<code>Bower</code>来管理依赖，输入以下命令来安装Bower：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g bower</span><br></pre></td></tr></table></figure><p>然后就可以通过<code>Bower</code>来管理各种依赖库了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bower install bootstrap</span><br></pre></td></tr></table></figure><p>通过这个命令，依赖库将被安装到<code>bower_components</code>当中，你可以在你的HTML页面里边直接引用</p><h1 id="搭建UI实例"><a href="#搭建UI实例" class="headerlink" title="搭建UI实例"></a>搭建UI实例</h1><p>安装前文所说，准备一个项目（package.json，main.js，index.html）<br>main.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;app, BrowserWindow&#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> win</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   win = <span class="keyword">new</span> BrowserWindow(&#123;<span class="attr">width</span>: <span class="number">800</span>, <span class="attr">height</span>: <span class="number">600</span>&#125;)</span><br><span class="line">   win.loadURL(url.format (&#123;</span><br><span class="line">      <span class="attr">pathname</span>: path.join(__dirname, <span class="string">&#x27;index.html&#x27;</span>),</span><br><span class="line">      <span class="attr">protocol</span>: <span class="string">&#x27;file:&#x27;</span>,</span><br><span class="line">      <span class="attr">slashes</span>: <span class="literal">true</span></span><br><span class="line">   &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">&#x27;ready&#x27;</span>, createWindow)</span><br></pre></td></tr></table></figure><p>安装JQuery：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save jquery</span><br></pre></td></tr></table></figure><p>index.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span> = <span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello Electron!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span> = <span class="string">&quot;stylesheet&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">href</span> = <span class="string">&quot;./bower_components/bootstrap/dist/css/bootstrap.min.css&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This page is using Bootstrap and jQuery!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span> = <span class="string">&quot;click-counter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span> = <span class="string">&quot;btn btn-success&quot;</span> <span class="attr">id</span> = <span class="string">&quot;countbtn&quot;</span>&gt;</span>Click here<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">&quot;./view.js&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>新建一个<code>view.js</code>，拷入以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> $ = <span class="built_in">require</span>(<span class="string">&#x27;jquery&#x27;</span>)  <span class="comment">// 引用jQuery并赋值给$符号</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">$(<span class="string">&#x27;#click-counter&#x27;</span>).text(count.toString())</span><br><span class="line">$(<span class="string">&#x27;#countbtn&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">   count ++ </span><br><span class="line">   $(<span class="string">&#x27;#click-counter&#x27;</span>).text(count)</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><p>输入命令，运行App：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ electron ./main.js</span><br></pre></td></tr></table></figure><p>运行结果如图：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;UI开发由于使用的是HTML、CSS、Javascript，所以以前怎么来，现在还是怎么来，你甚至可以使用以前用的习惯的各种框架：&lt;code&gt;Angular&lt;/code&gt;、&lt;code&gt;Bootstrap&lt;/code&gt;、&lt;code&gt;JQuery&lt;/c</summary>
      
    
    
    
    
    <category term="Electron" scheme="http://peceoqicka.github.io/project/tags/Electron/"/>
    
    <category term="HTML" scheme="http://peceoqicka.github.io/project/tags/HTML/"/>
    
    <category term="Javascript" scheme="http://peceoqicka.github.io/project/tags/Javascript/"/>
    
    <category term="CSS" scheme="http://peceoqicka.github.io/project/tags/CSS/"/>
    
    <category term="Desktop" scheme="http://peceoqicka.github.io/project/tags/Desktop/"/>
    
  </entry>
  
  <entry>
    <title>Electron学习笔记（一）：入门到环境搭建</title>
    <link href="http://peceoqicka.github.io/project/2018/07/10/electron-1/"/>
    <id>http://peceoqicka.github.io/project/2018/07/10/electron-1/</id>
    <published>2018-07-10T08:31:28.000Z</published>
    <updated>2018-07-10T09:26:41.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Electron"><a href="#什么是Electron" class="headerlink" title="什么是Electron"></a>什么是Electron</h1><blockquote><p><code>Electron</code>是由Github研发的使用<code>HTML</code>、<code>CSS</code>、<code>Javascript</code>开发跨平台桌面应用程序的开源开发框架。Electron通过把<code>Chromium</code>和<code>Node.js</code>结合进一个运行时中实现，它开发的app能够被打包为<code>Mac</code>、<code>Windows</code>和<code>Linux</code>平台的应用程序。</p></blockquote><p>提到跨平台桌面应用开发，最先想到的应该是<code>JavaFx</code>。JavaFx的一大特点是传统的XML语言结合Java进行开发，能够跨平台运行。但是我个人认为JavaFx那些控件写起来远不如<code>Android</code>当中的控件写起来更方便。这次偶然得知使用HTML来开发跨平台应用的框架，我很兴奋，毕竟用HTML来做UI是非常方便的，得益于它丰富的框架和成熟的体系。</p><p><a href="https://electronjs.org/">Electron官方网站</a><br><a href="https://www.tutorialspoint.com/electron/index.htm">学习参考教程</a></p><h1 id="Hello-Electron"><a href="#Hello-Electron" class="headerlink" title="Hello Electron"></a>Hello Electron</h1><p>必备环境：<a href="https://nodejs.org/en/">Node.js</a></p><p>按照教程所说，建议把Electron安装到每一个项目的依赖中，那么安装完<code>Node.js</code>之后，我们就可以着手开始做第一个App了</p><p>第一个App的名字就叫<code>HelloEla</code>，建立一个文件夹（D:\Work\ElectronProject\HelloEla），进入这个文件夹，右键点击空白处选择 <code>Git Bash Here</code></p><p>输入并执行<code>npm init</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">name: (helloela)</span><br><span class="line">version: (1.0.0)</span><br><span class="line">description:</span><br><span class="line">entry point: (index.js)</span><br><span class="line"><span class="built_in">test</span> <span class="built_in">command</span>:</span><br><span class="line">git repository:</span><br><span class="line">keywords:</span><br><span class="line">author: peceoqicka</span><br><span class="line">license: (ISC)</span><br><span class="line">About to write to D:/Work/ElectronProject/HelloEla/package.json:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;helloela&quot;</span>,</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;author&quot;</span>: <span class="string">&quot;peceoqicka&quot;</span>,</span><br><span class="line">    <span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Is this ok? (yes) yes</span><br></pre></td></tr></table></figure><p>一路回车即可，在提示<code>author</code>时输入你的名称，最后确认时回车会在<code>HelloEla目录</code>下生成一个名为<code>package.json</code>的文件</p><p>输入以下命令安装Electron：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g electron</span><br></pre></td></tr></table></figure><p>安装完成后可以输入以下命令检测是否正确安装，如果正确安装会提示版本号（我的是v2.0.4）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ electron -version</span><br></pre></td></tr></table></figure><p>新建一个文件名为<code>main.js</code>，并输入以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;app, BrowserWindow&#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>) </span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>) </span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> win  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">   win = <span class="keyword">new</span> BrowserWindow(&#123;<span class="attr">width</span>: <span class="number">800</span>, <span class="attr">height</span>: <span class="number">600</span>&#125;) </span><br><span class="line">   win.loadURL(url.format (&#123; </span><br><span class="line">      <span class="attr">pathname</span>: path.join(__dirname, <span class="string">&#x27;index.html&#x27;</span>), </span><br><span class="line">      <span class="attr">protocol</span>: <span class="string">&#x27;file:&#x27;</span>, </span><br><span class="line">      <span class="attr">slashes</span>: <span class="literal">true</span> </span><br><span class="line">   &#125;)) </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">app.on(<span class="string">&#x27;ready&#x27;</span>, createWindow)</span><br></pre></td></tr></table></figure><p>打开刚才生成的<code>package.json</code>，修改<code>main</code>的值为<code>main.js</code></p><p>接着再新建一个文件命名为<code>index.html</code>，打开文件，拷贝以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span> = <span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello Electron!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello Electron!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      We are using node <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">document</span>.write(process.versions.node)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>,</span><br><span class="line">      Chrome <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">document</span>.write(process.versions.chrome)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>,</span><br><span class="line">      and Electron <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">document</span>.write(process.versions.electron)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>.</span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在刚才打开的bash窗口中输入命令运行App：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ electron ./main.js</span><br></pre></td></tr></table></figure><p>能够看到一个弹出的窗口：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是Electron&quot;&gt;&lt;a href=&quot;#什么是Electron&quot; class=&quot;headerlink&quot; title=&quot;什么是Electron&quot;&gt;&lt;/a&gt;什么是Electron&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Electron&lt;/code&gt;</summary>
      
    
    
    
    
    <category term="Electron" scheme="http://peceoqicka.github.io/project/tags/Electron/"/>
    
    <category term="HTML" scheme="http://peceoqicka.github.io/project/tags/HTML/"/>
    
    <category term="Javascript" scheme="http://peceoqicka.github.io/project/tags/Javascript/"/>
    
    <category term="CSS" scheme="http://peceoqicka.github.io/project/tags/CSS/"/>
    
    <category term="Desktop" scheme="http://peceoqicka.github.io/project/tags/Desktop/"/>
    
  </entry>
  
  <entry>
    <title>Android实现支持适配器的FlowLayout</title>
    <link href="http://peceoqicka.github.io/project/2018/07/05/android-flowlayout/"/>
    <id>http://peceoqicka.github.io/project/2018/07/05/android-flowlayout/</id>
    <published>2018-07-05T07:13:11.000Z</published>
    <updated>2018-07-09T08:39:06.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FlowLayout"><a href="#FlowLayout" class="headerlink" title="FlowLayout"></a>FlowLayout</h1><blockquote><p>FlowLayout就是流式布局，为什么要起这么一个名字？因为大家都这么叫它，不管名字起得多么花哨，功能都是大同小异的。如图：</p></blockquote><h1 id="我为什么要实现流式布局？"><a href="#我为什么要实现流式布局？" class="headerlink" title="我为什么要实现流式布局？"></a>我为什么要实现流式布局？</h1><p>源于工作的需要，最近要做这么一个需求，有这么一些标签（数组，数量不确定，字数不确定），他们需要一个一个的往一个容器里边装，每个标签宽度不确定，如果标签在这一排放不下（剩余宽度不够），那么就要放到下一排。而且因为是数组，所以首先联想到的就是Adapter。</p><p>我也试着找寻官方提供的控件和第三方的开源框架，发现都没有完全满足我的需求的：</p><ul><li><a href="https://github.com/google/flexbox-layout">FlexBoxLayout</a>，很强大的控件，但不支持适配器</li><li><a href="https://github.com/hongyangAndroid/FlowLayout">FlowLayout</a>，大神写的控件，但是定制得太多</li><li>还有一些其他的，我就不细说了</li></ul><p>我需要的是一个容器控件，能够支持适配器，负责它所有的ChildView的布局（不需要ChildView的缓存），ChildView的宽高不定，不能限定每一行放多少个ChildView，不需要任何方向的滚动。所以，综上，我还是自己定义吧，与此同时，也能在自己实现的过程中提高自己的开发能力。</p><h1 id="那么开始吧"><a href="#那么开始吧" class="headerlink" title="那么开始吧"></a>那么开始吧</h1><p>自定义ViewGroup是老生常谈的话题，一个自定义ViewGroup的基本流程就是<em>获取布局参数-&gt;测量-&gt;布局</em></p><h2 id="框架搭建"><a href="#框架搭建" class="headerlink" title="框架搭建"></a>框架搭建</h2><p>FlowLayout我使用Kotlin来实现，基础框架搭建如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlowLayout</span> : <span class="type">ViewGroup &#123;</span></span></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context, attrs: AttributeSet?, defStyleAttr: <span class="built_in">Int</span>) : <span class="keyword">super</span>(context, attrs, defStyleAttr) &#123;</span><br><span class="line">        getParams(context, attrs, defStyleAttr)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context, attrs: AttributeSet?) : <span class="keyword">this</span>(context, attrs, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">constructor</span>(context: Context) : <span class="keyword">this</span>(context, <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取布局参数"><a href="#获取布局参数" class="headerlink" title="获取布局参数"></a>获取布局参数</h2><p>这里不需要过多的参数，只要两个，水平和竖直两个方向的边距：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getParams</span><span class="params">(context: <span class="type">Context</span>, attrs: <span class="type">AttributeSet</span>?, defStyleAttr: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    context.obtainStyledAttributes(attrs, R.styleable.FlowLayout, defStyleAttr, <span class="number">0</span>).apply &#123;</span><br><span class="line">        columnSpace = getDimensionPixelSize(R.styleable.FlowLayout_fl_columnSpace, <span class="number">0</span>)</span><br><span class="line">        rowSpace = getDimensionPixelSize(R.styleable.FlowLayout_fl_rowSpace, <span class="number">0</span>)</span><br><span class="line">        recycle()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h2><p>测量的主要目的是告诉FlowLayout的父级容器，我FlowLayout要占多大的空间。首先父级会告诉我们，我的测量模式和预设宽高：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> widthMode = View.MeasureSpec.getMode(widthMeasureSpec)</span><br><span class="line"><span class="keyword">val</span> heightMode = View.MeasureSpec.getMode(heightMeasureSpec)</span><br><span class="line"><span class="keyword">val</span> widthSize = View.MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line"><span class="keyword">val</span> heightSize = View.MeasureSpec.getSize(heightMeasureSpec)</span><br></pre></td></tr></table></figure><p>测量模式有且仅有三种：</p><ul><li>EXACTLY，“定了就这么多”，父级告诉自己一个确定的值</li><li>AT_MOST，“最多就这么多了”，父级给定一个最大值</li><li>UNSPECIFIED，“要多少有多少”，<strong>这种情况很少见</strong></li></ul><p>那么是不是在EXACTLY模式下，就不用测量了呢？当然不是，这里测量之后，还要给每个子View设置参数，方便在布局的时候计算每个子View放置的位置。</p><p>在测量时，需要考虑左右的padding：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> availableWidth = widthSize - paddingStart - paddingEnd</span><br></pre></td></tr></table></figure><p>测量子View时的基本方法是循环，在每次循环时判断是否需要换行，参考的依据就是，当前行已经占有的宽度加上当前ChildView要占据的宽度：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> childWidth = childView.measuredWidth + layoutParams.marginStart + layoutParams.marginEnd</span><br><span class="line"><span class="keyword">val</span> predictLineWidth = lineWidth + (<span class="keyword">if</span> (lineWidth == <span class="number">0</span>) childWidth <span class="keyword">else</span> (columnSpace + childWidth))</span><br><span class="line"><span class="keyword">if</span> (predictLineWidth &lt;= availableWidth) &#123;</span><br><span class="line">    <span class="comment">//不换行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了便于布局，要在测量时，计算出每一个ChildView的行列号并赋值给相应的LayoutParams。因此我们需要自定义一个LayoutParams类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutParams</span> : <span class="type">MarginLayoutParams &#123;</span></span></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context, attrs: AttributeSet) : <span class="keyword">super</span>(context, attrs)</span><br><span class="line">    <span class="meta">@Suppress(<span class="meta-string">&quot;unused&quot;</span>)</span></span><br><span class="line">    <span class="keyword">constructor</span>(width: <span class="built_in">Int</span>, height: <span class="built_in">Int</span>) : <span class="keyword">super</span>(width, height)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(source: ViewGroup.LayoutParams) : <span class="keyword">super</span>(source)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> layoutColumn = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> layoutRow = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环计算时，需要几个变量：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxLineWidth = <span class="number">0</span> <span class="comment">//最大行宽</span></span><br><span class="line"><span class="keyword">var</span> maxLineHeight = <span class="number">0</span> <span class="comment">//最大行高</span></span><br><span class="line"><span class="keyword">var</span> lineWidth = <span class="number">0</span> <span class="comment">//行宽</span></span><br><span class="line"><span class="keyword">var</span> totalHeight = <span class="number">0</span> <span class="comment">//所有行占用的总高度</span></span><br><span class="line"><span class="keyword">var</span> columnIndex = <span class="number">0</span> <span class="comment">//列顺序</span></span><br><span class="line"><span class="keyword">var</span> rowIndex = <span class="number">0</span> <span class="comment">//行顺序</span></span><br></pre></td></tr></table></figure><p>循环计算的完整代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span> until childCount).forEach &#123;</span><br><span class="line">    <span class="keyword">val</span> childView = getChildAt(it)</span><br><span class="line">    measureChildWithMargins(childView, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> layoutParams = childView.layoutParams <span class="keyword">as</span> FlowLayout.LayoutParams</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> childWidth = childView.measuredWidth + layoutParams.marginStart + layoutParams.marginEnd</span><br><span class="line">    <span class="keyword">val</span> childHeight = childView.measuredHeight + layoutParams.topMargin + layoutParams.bottomMargin</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> predictLineWidth = lineWidth + (<span class="keyword">if</span> (lineWidth == <span class="number">0</span>) childWidth <span class="keyword">else</span> (columnSpace + childWidth))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (predictLineWidth &lt;= availableWidth) &#123;</span><br><span class="line">        <span class="comment">//不换行</span></span><br><span class="line">        lineWidth = predictLineWidth</span><br><span class="line">        maxLineHeight = Math.max(maxLineHeight, childHeight)</span><br><span class="line"></span><br><span class="line">        layoutParams.layoutColumn = columnIndex</span><br><span class="line">        layoutParams.layoutRow = rowIndex</span><br><span class="line"></span><br><span class="line">        columnIndex++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//换行</span></span><br><span class="line">        columnIndex = <span class="number">0</span></span><br><span class="line">        rowIndex++</span><br><span class="line">        maxLineWidth = Math.max(lineWidth, maxLineWidth)</span><br><span class="line">        totalHeight += (maxLineHeight + rowSpace)</span><br><span class="line">        lineHeightList.add(maxLineHeight)</span><br><span class="line"></span><br><span class="line">        layoutParams.layoutColumn = columnIndex</span><br><span class="line">        layoutParams.layoutRow = rowIndex</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果恰好是最后一行，最大行高值不应该置0，在循环完成之后补上最后一行的行高</span></span><br><span class="line">        maxLineHeight = <span class="keyword">if</span> (it == childCount - <span class="number">1</span>) maxLineHeight <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        lineWidth = childWidth</span><br><span class="line">        columnIndex++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">totalHeight += maxLineHeight</span><br><span class="line">lineHeightList.add(maxLineHeight)</span><br></pre></td></tr></table></figure><p>其中有几个要点如下：</p><ul><li><p>循环完成之后要补上最后一行的行高</p></li><li><p>换行时将columnIndex置0，rowIndex加1，然后赋值给对应的LayoutParams，赋值完成之后一定要给columnIndex加1</p></li></ul><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>布局相对简单，因为大多数的工作前边测量时已经完成了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span> until childCount).forEach &#123;</span><br><span class="line">    <span class="keyword">val</span> childView = getChildAt(it)</span><br><span class="line">    <span class="keyword">val</span> layoutParams = childView.layoutParams <span class="keyword">as</span> FlowLayout.LayoutParams</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> cLeft = paddingStart + layoutParams.marginStart + calculateLeftPosition(it, layoutParams.layoutColumn)</span><br><span class="line">    <span class="keyword">val</span> cTop = paddingTop + calculateTopPosition(it, layoutParams.layoutRow)</span><br><span class="line">    <span class="keyword">val</span> cRight = cLeft + childView.measuredWidth</span><br><span class="line">    <span class="keyword">val</span> cBottom = cTop + childView.measuredHeight</span><br><span class="line"></span><br><span class="line">    childView.layout(cLeft, cTop, cRight, cBottom)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在计算childView的左边的距离时，使用递归来计算，不要算上本身的左边距：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">calculateLeftPosition</span><span class="params">(layoutIndex: <span class="type">Int</span>, colIndex: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (colIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> previousChild = getChildAt(layoutIndex - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">val</span> previousLayoutParams = previousChild.layoutParams <span class="keyword">as</span> FlowLayout.LayoutParams</span><br><span class="line">        <span class="keyword">val</span> previousWidth = previousChild.measuredWidth + previousLayoutParams.marginStart + previousLayoutParams.marginEnd</span><br><span class="line">        columnSpace + previousWidth + calculateLeftPosition(layoutIndex - <span class="number">1</span>, colIndex - <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边的距离则相对简单，原理同计算左边距：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">calculateTopPosition</span><span class="params">(layoutIndex: <span class="type">Int</span>, rowIndex: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (rowIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        rowSpace + lineHeightList[rowIndex] + calculateTopPosition(layoutIndex - <span class="number">1</span>, rowIndex - <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监听适配器刷新"><a href="#监听适配器刷新" class="headerlink" title="监听适配器刷新"></a>监听适配器刷新</h2><p>当我们在调用适配器的notifyDataSetChanged方法的时候，FlowLayout需要作出响应，刷新布局，因此，需要一个DataSetObserver：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterDataSetObserver</span> : <span class="type">DataSetObserver</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onChanged</span><span class="params">()</span></span> &#123;</span><br><span class="line">        resetData()</span><br><span class="line">        requestLayout()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onInvalidated</span><span class="params">()</span></span> &#123;</span><br><span class="line">        resetData()</span><br><span class="line">        requestLayout()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>notifyDataSetChanged()</code>会触发这里的<code>onChanged()</code>方法，调用<code>notifyDataSetInvalidated()</code>会触发这里的<code>onInvalidated()</code>方法，但是还没完，写好了之后还要“注册”：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAttachedToWindow</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onAttachedToWindow()</span><br><span class="line">    <span class="keyword">if</span> ((adapter != <span class="literal">null</span>) and (adapterDataSetObserver == <span class="literal">null</span>)) &#123;</span><br><span class="line">        adapterDataSetObserver = AdapterDataSetObserver()</span><br><span class="line">        adapter?.registerDataSetObserver(adapterDataSetObserver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在重设适配器时也需要重新“绑定”：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setAdapter</span><span class="params">(adapter: <span class="type">BaseAdapter</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.adapter !== adapter) &#123;</span><br><span class="line">        <span class="keyword">this</span>.adapter?.let &#123; a -&gt;</span><br><span class="line">            adapterDataSetObserver?.let &#123; o -&gt;</span><br><span class="line">                a.unregisterDataSetObserver(o)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        adapter?.let &#123;</span><br><span class="line">            adapterDataSetObserver = AdapterDataSetObserver()</span><br><span class="line">            it.registerDataSetObserver(adapterDataSetObserver)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.adapter = it.apply &#123;</span><br><span class="line">                (<span class="number">0</span> until <span class="keyword">this</span><span class="symbol">@apply</span>.count).forEach &#123;</span><br><span class="line">                    <span class="keyword">val</span> childView = <span class="keyword">this</span><span class="symbol">@apply</span>.getView(it, <span class="literal">null</span>, <span class="keyword">this</span><span class="symbol">@FlowLayout</span>)</span><br><span class="line">                    addView(childView,generateLayoutParams(childView.layoutParams))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            requestLayout()</span><br><span class="line">        &#125; ?: let &#123;</span><br><span class="line">            <span class="keyword">this</span>.adapter = <span class="literal">null</span></span><br><span class="line">            removeAllViews()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的就没什么可说的了，当然这个FlowLayout设计肯定还是有缺陷的，以后会逐渐的改进</p><p>Github地址：<a href="https://github.com/peceoqicka/FlowLayoutDemo">https://github.com/peceoqicka/FlowLayoutDemo</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;FlowLayout&quot;&gt;&lt;a href=&quot;#FlowLayout&quot; class=&quot;headerlink&quot; title=&quot;FlowLayout&quot;&gt;&lt;/a&gt;FlowLayout&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;FlowLayout就是流式布局，为什么要起这么一</summary>
      
    
    
    
    
    <category term="Android" scheme="http://peceoqicka.github.io/project/tags/Android/"/>
    
    <category term="Kotlin" scheme="http://peceoqicka.github.io/project/tags/Kotlin/"/>
    
    <category term="ViewGroup" scheme="http://peceoqicka.github.io/project/tags/ViewGroup/"/>
    
  </entry>
  
  <entry>
    <title>JavaFx学习笔记（一）第一个桌面程序与Kotlin</title>
    <link href="http://peceoqicka.github.io/project/2018/03/14/javafx-1-basic/"/>
    <id>http://peceoqicka.github.io/project/2018/03/14/javafx-1-basic/</id>
    <published>2018-03-14T01:28:05.000Z</published>
    <updated>2018-03-14T08:55:13.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一个桌面应用程序"><a href="#第一个桌面应用程序" class="headerlink" title="第一个桌面应用程序"></a>第一个桌面应用程序</h1><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>Application是一个程序的入口，基本等价于Android的Application：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javafx.application.Application</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> : <span class="type">Application</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">(primaryStage: <span class="type">Stage</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">//舞台的交互代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Application的启动必须在Java类的main方法中调用：（在Kotlin的main方法中无法识别）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppEntrance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Application.launch(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Stage"><a href="#Stage" class="headerlink" title="Stage"></a>Stage</h2><p>Stage就等于是一个窗口，它有一切窗口的要素：标题栏、内容等。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">primaryStage.apply &#123;</span><br><span class="line">    title = <span class="string">&quot;My Window Title&quot;</span></span><br><span class="line">    <span class="comment">//场景大小</span></span><br><span class="line">    scene = Scene(root, <span class="number">300.0</span>, <span class="number">300.0</span>)</span><br><span class="line">    <span class="comment">//是否最大化，是否占满屏幕</span></span><br><span class="line">    isMaximized = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//是否可由用户控制窗口缩放</span></span><br><span class="line">    isResizable = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//是否全屏（如果是，会挡住windows的任务栏）</span></span><br><span class="line">    isFullScreen = <span class="literal">false</span></span><br><span class="line">    <span class="comment">//点击窗口关闭按钮的回调方法</span></span><br><span class="line">    onCloseRequest = EventHandler&lt;WindowEvent&gt; &#123; onApplicationExit() &#125;</span><br><span class="line">&#125;.show()</span><br></pre></td></tr></table></figure><h2 id="Layout和FXMLLoader"><a href="#Layout和FXMLLoader" class="headerlink" title="Layout和FXMLLoader"></a>Layout和FXMLLoader</h2><p>布局文件的格式为.fxml，类似于Android中的xml，fxml也是一种xml。同时，Android有LayoutInflater，JavaFx有FXMLLoader。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> loader = FXMLLoader(javaClass.getResource(<span class="string">&quot;ui/layout_main.fxml&quot;</span>))</span><br><span class="line"><span class="comment">//读取layout的根ViewGroup</span></span><br><span class="line"><span class="keyword">val</span> root = loader.load&lt;Parent&gt;()</span><br></pre></td></tr></table></figure><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>控制器类，顾名思义，布局文件的控制代码就放在里边，JavaFx使用的是MVC模式。</p><h3 id="Controller与Layout绑定"><a href="#Controller与Layout绑定" class="headerlink" title="Controller与Layout绑定"></a>Controller与Layout绑定</h3><p>控制器类与布局文件的绑定方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BorderPane</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://javafx.com/javafx/8.0.121&quot;</span> <span class="attr">xmlns:fx</span>=<span class="string">&quot;http://javafx.com/fxml/1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">fx:controller</span>=<span class="string">&quot;com.peceoqicka.ui.MainController&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 布局代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">BorderPane</span>&gt;</span></span><br></pre></td></tr></table></figure><p>绑定之后可通过FXMLLoader得到：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> controller = loader.getController&lt;MainController&gt;()</span><br></pre></td></tr></table></figure><h3 id="获取View"><a href="#获取View" class="headerlink" title="获取View"></a>获取View</h3><p>在Controller中获取布局中的View的方式是，给相应的View绑定一个id：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">WebView</span> <span class="attr">fx:id</span>=<span class="string">&quot;wvContent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>然后在Controller中使用与id相同的变量名定义一个<strong>public</strong>的变量即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javafx.scene.web.WebView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> wvContent: WebView</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>在布局文件中相应控件上添加onAction字段，填写**#方法名**即可。</p><p>然后在Controller中定义一个<strong>public</strong>的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onActionTips</span><span class="params">(actionEvent: <span class="type">ActionEvent</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//actionEvent为有且仅有一个的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一个桌面应用程序&quot;&gt;&lt;a href=&quot;#第一个桌面应用程序&quot; class=&quot;headerlink&quot; title=&quot;第一个桌面应用程序&quot;&gt;&lt;/a&gt;第一个桌面应用程序&lt;/h1&gt;&lt;h2 id=&quot;Application&quot;&gt;&lt;a href=&quot;#Application&quot; c</summary>
      
    
    
    
    <category term="Development" scheme="http://peceoqicka.github.io/project/categories/Development/"/>
    
    
    <category term="Kotlin" scheme="http://peceoqicka.github.io/project/tags/Kotlin/"/>
    
    <category term="Java" scheme="http://peceoqicka.github.io/project/tags/Java/"/>
    
    <category term="JavaFx" scheme="http://peceoqicka.github.io/project/tags/JavaFx/"/>
    
  </entry>
  
  <entry>
    <title>Databinding踩坑记录</title>
    <link href="http://peceoqicka.github.io/project/2018/01/25/android-binding-trouble-log/"/>
    <id>http://peceoqicka.github.io/project/2018/01/25/android-binding-trouble-log/</id>
    <published>2018-01-25T06:57:39.000Z</published>
    <updated>2018-03-14T08:54:47.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题1：DataBinding在Kotlin中使用时编译无法通过"><a href="#问题1：DataBinding在Kotlin中使用时编译无法通过" class="headerlink" title="问题1：DataBinding在Kotlin中使用时编译无法通过"></a>问题1：DataBinding在Kotlin中使用时编译无法通过</h2><p>要在Kotlin中使用DataBinding需要在<code>app/build.gradle</code>中添加如下代码：</p><ul><li><p>Kapt插件:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;kotlin-kapt&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>打开databinding开关：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">databinding &#123;</span><br><span class="line">  enabled = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>kapt databinding compiler：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kapt <span class="string">&#x27;com.android.databinding:compiler:3.0.0&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><p>最终<code>build.gradle</code>的内容应该与下面相似：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;kotlin-android&#x27;</span></span><br><span class="line">...<span class="comment">//省略其他插件</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;kotlin-kapt&#x27;</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    ...<span class="comment">//省略其他配置信息</span></span><br><span class="line">    dataBinding &#123;</span><br><span class="line">        enabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">//这里的版本号等同于项目的build.gradle文件中的android编译器的版本</span></span><br><span class="line">    <span class="comment">//classpath &#x27;com.android.tools.build:gradle:3.0.0&#x27;</span></span><br><span class="line">    kapt <span class="string">&#x27;com.android.databinding:compiler:3.0.0&#x27;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题2：没有生成XML文件对应的Binding类？"><a href="#问题2：没有生成XML文件对应的Binding类？" class="headerlink" title="问题2：没有生成XML文件对应的Binding类？"></a>问题2：没有生成XML文件对应的Binding类？</h2><blockquote><p>生成Binding类的名称默认为XML文件的名称去掉下划线并以驼峰命名法顺序排出所有单词。</p></blockquote><p>例如：activity_main.xml生成的类名叫ActivityMainBinding</p><h2 id="问题3：我需要一个变量在代码中产生了值的变化，同步变化到绑定的View上怎么做？"><a href="#问题3：我需要一个变量在代码中产生了值的变化，同步变化到绑定的View上怎么做？" class="headerlink" title="问题3：我需要一个变量在代码中产生了值的变化，同步变化到绑定的View上怎么做？"></a>问题3：我需要一个变量在代码中产生了值的变化，同步变化到绑定的View上怎么做？</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PwdData</span> : <span class="type">BaseObservable</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> minPwdLengthError: String = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">set</span>(value) &#123;</span><br><span class="line">                field = value;notifyPropertyChanged(BR.minPwdLengthError)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Bindable</span></span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先Data class需要继承BaseObservable；其次@Bindable注解需要且仅需要打在get方法上；然后关注变化的语句是notifyPropertyChanged，BR.minPwdLengthError是编译器生成的唯一ID，在给get方法打上注解之后，重新build之后自动生成。</p><h2 id="问题4：我要自定义属性绑定怎么办？"><a href="#问题4：我要自定义属性绑定怎么办？" class="headerlink" title="问题4：我要自定义属性绑定怎么办？"></a>问题4：我要自定义属性绑定怎么办？</h2><p>AppBinding.kt（Kotlin文件，不是Kotlin类）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">&quot;bind:spinnerAdapter&quot;</span>)</span></span><br><span class="line"><span class="comment">//android自带属性（如ImageView的src）的绑定请将上方的bind改为android即可</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setSpinnerAdapter</span><span class="params">(spinner: <span class="type">Spinner</span>, adapter: <span class="type">BaseAdapter</span>)</span></span> &#123;</span><br><span class="line">    spinner.adapter = adapter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中spinnerAdapter是一个自定义属性（res/values/attrs.xml）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里的自定义属性的格式任意皆可，我统一使用reference--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;spinnerAdapter&quot;</span> <span class="attr">format</span>=<span class="string">&quot;reference&quot;</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在xml布局文件中调用如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Spinner</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/spi_fra_pwd_generation_count&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:spinnerAdapter</span>=<span class="string">&quot;@&#123;pwdData.gcSpinnerAdapter&#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="问题5：我该把-BindingAdapter的自定义方法放在哪"><a href="#问题5：我该把-BindingAdapter的自定义方法放在哪" class="headerlink" title="问题5：我该把@BindingAdapter的自定义方法放在哪"></a>问题5：我该把@BindingAdapter的自定义方法放在哪</h2><p>很简单，新建一个Kotlin文件即可（不要类），直接在文件里边写“包级”方法。</p><h2 id="问题6：自定义绑定方法要多个参数该怎么办？"><a href="#问题6：自定义绑定方法要多个参数该怎么办？" class="headerlink" title="问题6：自定义绑定方法要多个参数该怎么办？"></a>问题6：自定义绑定方法要多个参数该怎么办？</h2><p>So Easy！有多少写多少</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">&quot;bind:imageUrl&quot;</span>, <span class="meta-string">&quot;bind:placeholder&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">loadImageUrl</span><span class="params">(imageView: <span class="type">ImageView</span>, url: <span class="type">String</span>, placeholder: <span class="type">Drawable</span>)</span></span> &#123;</span><br><span class="line">    Glide.with(imageView.context).load(url)</span><br><span class="line">            .apply(RequestOptions().centerCrop().placeholder(placeholder))</span><br><span class="line">            .into(imageView)</span><br><span class="line">    println(placeholder)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里是将两个自定义属性绑到同一个方法上，第一个参数必须是写了这几个属性的View。后续几个自定义的参数类型必须一一对应，比如placeholder参数传入的是”@{@drawable/ic_xxx}”，那么方法这里的类型必须是Drawable。</p><p>另外，为了应对参数变化情况，你可以同时写好几种情况的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三个参数的方法</span></span><br><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">&quot;bind:urlDomain&quot;</span>, <span class="meta-string">&quot;bind:imageUrl&quot;</span>, <span class="meta-string">&quot;bind:placeholder&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">loadImageUrl</span><span class="params">(imageView: <span class="type">ImageView</span>, urlDomain: <span class="type">String</span>, url: <span class="type">String</span>, placeholder: <span class="type">Drawable</span>)</span></span> &#123;</span><br><span class="line">    Glide.with(imageView.context).load(urlDomain + url)</span><br><span class="line">            .apply(RequestOptions().centerCrop().placeholder(placeholder))</span><br><span class="line">            .into(imageView)</span><br><span class="line">    println(placeholder)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题7：我要双向绑定怎么办？"><a href="#问题7：我要双向绑定怎么办？" class="headerlink" title="问题7：我要双向绑定怎么办？"></a>问题7：我要双向绑定怎么办？</h2><p>何为双向绑定？</p><blockquote><p>简而言之就是，我在View中修改了值的状态，希望同步变化到绑定的变量上</p></blockquote><p>android自带的属性都几乎已经为你准备好了相应的双向绑定适配器，而一些其他属性或者你自己定义的属性，需要自己写适配器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题1：DataBinding在Kotlin中使用时编译无法通过&quot;&gt;&lt;a href=&quot;#问题1：DataBinding在Kotlin中使用时编译无法通过&quot; class=&quot;headerlink&quot; title=&quot;问题1：DataBinding在Kotlin中使用时编译</summary>
      
    
    
    
    <category term="Development" scheme="http://peceoqicka.github.io/project/categories/Development/"/>
    
    
    <category term="Android" scheme="http://peceoqicka.github.io/project/tags/Android/"/>
    
    <category term="DataBinding" scheme="http://peceoqicka.github.io/project/tags/DataBinding/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建记录</title>
    <link href="http://peceoqicka.github.io/project/2018/01/24/blog-build/"/>
    <id>http://peceoqicka.github.io/project/2018/01/24/blog-build/</id>
    <published>2018-01-24T07:39:50.000Z</published>
    <updated>2021-09-27T09:03:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><ul><li>更换主题为<a href="https://github.com/next-theme/hexo-theme-next">Next</a>（由于Melody主题未知BUG无法正确生成一些页面而不得不替换）<br>并升级<strong>hexo</strong>到<strong>5.x</strong>版本<br>2021年9月27日17:03:21</li><li>初次搭建完成时间<br>2018年1月24日15:40:16</li><li>更换主题为<a href="https://github.com/Molunerfinn/hexo-theme-melody">Melody</a><br>2018年7月5日15:03:55</li></ul><h1 id="基本步骤记录"><a href="#基本步骤记录" class="headerlink" title="基本步骤记录"></a>基本步骤记录</h1><blockquote><p>这是一篇笔记，记录如何通过<strong>Github Pages</strong>和<a href="https://hexo.io/">Hexo</a>搭建个人博客的过程。包含完整的配置记录。</p></blockquote><p>参考教程：<a href="http://ryane.top/2018/01/10/2018%EF%BC%8C%E4%BD%A0%E8%AF%A5%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%BA%86%EF%BC%81/">《2018，你该搭建自己的博客了！》</a></p><h2 id="Hexo是什么"><a href="#Hexo是什么" class="headerlink" title="Hexo是什么"></a>Hexo是什么</h2><blockquote><p>Hexo是一个快速, 简洁且高效的博客框架. 让上百个页面在几秒内瞬间完成渲染. Hexo支持Github Flavored Markdown的所有功能, 甚至可以整合Octopress的大多数插件. 并自己也拥有强大的插件系统.</p></blockquote><p>之所以使用github和hexo来搭建，是因为这种方式几乎是最快捷以及适合新手搭建个人博客的方式。Github Pages省去了自己搭建服务器的烦恼；Hexo帮你完成你的博客的外观（有许多漂亮的主题可以选择）。你只需要简单的配置即可轻松搭建一个漂亮的个人博客。</p><h2 id="基本准备"><a href="#基本准备" class="headerlink" title="基本准备"></a>基本准备</h2><ul><li>Github账号</li><li>Node.js</li><li>Git客户端</li><li>Github SSH密钥和本地仓库</li><li>Hexo</li></ul><p>前4项不再过多赘述，参考搜索到的教程即可。</p><h2 id="安装和使用Hexo"><a href="#安装和使用Hexo" class="headerlink" title="安装和使用Hexo"></a>安装和使用Hexo</h2><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><ul><li>在本地磁盘任意地点新建文件夹（用于存储站点源文件，如D:/Work/Blog/Hexo）</li><li>进入文件夹，右键点击空白处选择<code>Git Bash Here</code></li><li>在弹出的<code>git bash窗口</code>中输入以下命令安装Hexo：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装Hexo</span></span><br><span class="line">npm install hexo-cli -g</span><br><span class="line"><span class="comment"># 初始化Hexo目录</span></span><br><span class="line">hexo init</span><br><span class="line"><span class="comment"># 安装Git部署器</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>安装完成后可以看到目录结构如下：</li></ul><h3 id="建立Github-Pages项目"><a href="#建立Github-Pages项目" class="headerlink" title="建立Github Pages项目"></a>建立Github Pages项目</h3><ul><li>打开自己的Github新建项目：<br> （项目名称要求格式：xxxxx（github用户名）.github.io）</li><li>打开刚才建立的项目，点<code>Clone or download</code>，点击<code>Use SSH</code>，然后复制链接</li></ul><h3 id="将Hexo站点源码提交到Github-Pages项目"><a href="#将Hexo站点源码提交到Github-Pages项目" class="headerlink" title="将Hexo站点源码提交到Github Pages项目"></a>将Hexo站点源码提交到Github Pages项目</h3><ul><li>用文本编辑器打开hexo根目录下的配置文件<code>_config.yml</code>（yml是<a href="http://frontenddev.org/article/yaml-language-introductory-tutorial.html">yaml</a>格式的文件后缀）</li><li>找到<code>deploy:</code>修改为如下内容并保存：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">xxx</span> <span class="comment">#刚才复制的SSH链接</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"><span class="comment">#注意每个字段的冒号后边必须有一个空格，且缩进靠空格不靠tab</span></span><br></pre></td></tr></table></figure></li><li>在Git Bash窗口中（定位为博客源码根目录，如D:/Work/Blog/Hexo）输入命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成静态文件</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="comment">#部署（提交）站点源码,可能会要求输入github账号密码</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li><li>在github查看项目源代码，如果部署成功，即可在浏览器地址栏输入链接<code>http://[你的github用户名].github.io/</code>访问你的博客了</li></ul><h3 id="本地编辑和预览博客"><a href="#本地编辑和预览博客" class="headerlink" title="本地编辑和预览博客"></a>本地编辑和预览博客</h3><ul><li><p>写文章的方式是在博客根目录打开bash输入以下命令：（建议使用此方式）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;这里填写文章标题&quot;</span></span><br></pre></td></tr></table></figure><p>生成的文章文件名为<code>标题.md</code>，文章使用markdown编写。<strong>建议这里输入的文章标题只有英文字符或数字，博客页面显示的文章标题在文件内通过标题字段单独设置</strong>。<br>生成的文件位置在博客根目录可以看到的<code>source/_posts/</code>目录下，用任意文本编辑器打开即可编辑。</p></li><li><p>修改文章内容或者修改hexo配置之后，输入以下<a id='blog1'>命令</a>进行本地预览：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#清除缓存和生成的静态文件（可选，如果遇到只读取缓存没有更新的情况可以使用）</span></span><br><span class="line">hexo clean</span><br><span class="line"><span class="comment">#重新生成静态文件</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="comment">#启动本地服务器</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>启动本地服务器后，在浏览器输入<code>http://localhost:4000/</code>访问本地博客预览效果</p></li></ul><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><ul><li>在Hexo官方网站的主题页面可以选择喜欢的主题进行安装，如图：</li><li>点击图片可以打开预览页面，点击标题进入相应的Github项目页面。</li><li>这里我选择了<a href="https://github.com/viosey/hexo-theme-material">Material</a>，在博客的themes目录下打开git bash，输入命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> xxx <span class="comment">#(主题的github项目地址)</span></span><br></pre></td></tr></table></figure></li><li>克隆完成后可以将主题的文件夹名称改短，这里改为material，起一个简短的名称即可（这个名称用于在站点配置文件中切换主题）</li><li>打开<code>站点配置文件_config.yml</code>，找到theme字段，修改它的value为上一步的<code>主题文件夹名称</code>，这里为material。</li><li>按照之前所说的<a href='#blog1'>命令</a>预览效果：</li></ul><h3 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h3><ul><li>站点的基本配置参考<a href="https://hexo.io/zh-cn/docs/configuration.html">Hexo配置</a>，有些设置会以主题的配置为准（视具体的主题而定，一般第三方主题都有参考手册）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;日志&quot;&gt;&lt;a href=&quot;#日志&quot; class=&quot;headerlink&quot; title=&quot;日志&quot;&gt;&lt;/a&gt;日志&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;更换主题为&lt;a href=&quot;https://github.com/next-theme/hexo-theme-next&quot;&gt;Nex</summary>
      
    
    
    
    <category term="Development" scheme="http://peceoqicka.github.io/project/categories/Development/"/>
    
    
    <category term="Log" scheme="http://peceoqicka.github.io/project/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>Markdown支持度测试</title>
    <link href="http://peceoqicka.github.io/project/2018/01/23/markdown-syntax/"/>
    <id>http://peceoqicka.github.io/project/2018/01/23/markdown-syntax/</id>
    <published>2018-01-23T08:11:12.000Z</published>
    <updated>2018-01-24T07:36:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><strong>粗体</strong>、<em>斜体</em>、<del>删除线</del></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul><li>C++</li><li>Java</li><li>Kotlin</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><ol><li>Android</li><li>IOS</li><li>HTML5</li></ol><h2 id="代办列表"><a href="#代办列表" class="headerlink" title="代办列表"></a>代办列表</h2><ul><li><input disabled="" type="checkbox"> 签到</li><li><input checked="" disabled="" type="checkbox"> 打卡</li></ul><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><blockquote><p>$$f(x)=\int_a^b{5x^6dx}$$</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.em.test;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Sorry, I&#x27;m the spy send by Kotlin&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流程图-不支持"><a href="#流程图-不支持" class="headerlink" title="流程图*(不支持)*"></a>流程图*(不支持)*</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: 某种操作</span><br><span class="line">cond=&gt;condition: 没有了吗?</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><h2 id="序列图-不支持"><a href="#序列图-不支持" class="headerlink" title="序列图*(不支持)*"></a>序列图*(不支持)*</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am fine，thank u and you?</span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table><thead><tr><th align="center">名称</th><th align="center">单价</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">索泰（ZOTAC） GTX1080-8GD5X</td><td align="center">￥5099</td><td align="center">1</td></tr><tr><td align="center">海盗船（USCorsair）额定750W RM750x 电源</td><td align="center">￥999</td><td align="center">1</td></tr><tr><td align="center">金士顿(Kingston)骇客神条 Fury系列 DDR4 2400 8G</td><td align="center">￥729</td><td align="center">2</td></tr><tr><td align="center">三星(SAMSUNG) 960 EVO 250G M.2 NVMe</td><td align="center">￥819</td><td align="center">1</td></tr><tr><td align="center">西部数据（WD） 蓝盘 1TB 64MB7200转1T</td><td align="center">￥299</td><td align="center">1</td></tr></tbody></table><h2 id="图片链接"><a href="#图片链接" class="headerlink" title="图片链接"></a>图片链接</h2><p><img src="http://www.qq1234.org/uploads/allimg/150506/113K13046-5.jpg" alt="网络图片"></p><p><a href="http://www.qq1234.org/uploads/allimg/150506/113K13046-5.jpg">图片地址</a></p><h2 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h2><p><span style='text-decoration:underline;color:white;background:#0099FF;font-size:18px;'>使用html标签和css实现下划线和颜色变化</span></p><h2 id="脚注-不支持"><a href="#脚注-不支持" class="headerlink" title="脚注*(不支持)*"></a>脚注*(不支持)*</h2><blockquote><p>为文章添加一些脚注，例如：掘金[^Juejin]</p></blockquote><p>[^Juejin]: <a href="https://juejin.im/timeline">掘金</a>是一个帮助开发者成长的社区,是给开发者用的 Hacker News,给设计师用的 Designer News,和给产品经理用的 Medium。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;粗体&lt;/strong&gt;、&lt;em&gt;斜体&lt;/em&gt;、&lt;del&gt;删除线&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&quot;列表&quot;</summary>
      
    
    
    
    <category term="Development" scheme="http://peceoqicka.github.io/project/categories/Development/"/>
    
    
    <category term="Markdown" scheme="http://peceoqicka.github.io/project/tags/Markdown/"/>
    
  </entry>
  
</feed>
